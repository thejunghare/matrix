{"version":3,"file":"sync-accumulator.js","names":["logger","deepCopy","MAX_STICKY_DURATION_MS","UNREAD_THREAD_NOTIFICATIONS","ReceiptAccumulator","Category","isTaggedEvent","event","undefined","SyncAccumulator","constructor","opts","arguments","length","_defineProperty","maxTimelineEntries","accumulate","syncResponse","fromDatabase","accumulateRooms","accumulateAccountData","nextBatch","next_batch","account_data","events","forEach","e","accountData","type","rooms","invite","Object","keys","roomId","accumulateRoom","Invite","join","Join","leave","Leave","knock","Knock","category","data","knockRooms","accumulateInviteState","accumulateKnockState","inviteRooms","accumulateJoinState","joinRooms","error","invite_state","currentData","hasAdded","i","current","state_key","push","knock_state","_ref","_data","_data$ephemeral","_data$state","_data$orgMatrixMsc","_data$timeline","_data$msc4354_sticky","now","Date","_currentState","create","_timeline","_accountData","_unreadNotifications","_unreadThreadNotifications","_summary","_receipts","_stickyEvents","unread_notifications","stable","unstable","summary","_sum$HEROES_KEY","_sum$JOINED_COUNT_KEY","_sum$INVITED_COUNT_KE","HEROES_KEY","INVITED_COUNT_KEY","JOINED_COUNT_KEY","acc","sum","consumeEphemeralEvents","ephemeral","timeline","limited","state","setState","index","_data$timeline$prev_b","transformedEvent","_e$unsigned","assign","unsigned","age","_localTs","token","prev_batch","filter","_ref2","expiresTs","msc4354_sticky","concat","map","cappedDuration","Math","min","duration_ms","createdTs","origin_server_ts","startIndex","slice","getJSON","forDatabase","_roomData$_stickyEven","roomData","roomJson","evType","receiptEvent","buildAccumulatedReceiptEvent","msgData","rollBackState","timelineEvent","prevStateEvent","prev_content","content","prev_sender","sender","stateKey","ev","accData","roomsData","getNextBatchToken","eventMap"],"sources":["../src/sync-accumulator.ts"],"sourcesContent":["/*\nCopyright 2017 - 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * This is an internal module. See {@link SyncAccumulator} for the public class.\n */\n\nimport { logger } from \"./logger.ts\";\nimport { deepCopy } from \"./utils.ts\";\nimport { MAX_STICKY_DURATION_MS, type IContent, type IUnsigned } from \"./models/event.ts\";\nimport { type IRoomSummary } from \"./models/room-summary.ts\";\nimport { type EventType } from \"./@types/event.ts\";\nimport { UNREAD_THREAD_NOTIFICATIONS } from \"./@types/sync.ts\";\nimport { ReceiptAccumulator } from \"./receipt-accumulator.ts\";\nimport { type OlmEncryptionInfo } from \"./crypto-api/index.ts\";\n\ninterface IOpts {\n    /**\n     * The ideal maximum number of timeline entries to keep in the sync response.\n     * This is best-effort, as clients do not always have a back-pagination token for each event,\n     * so it's possible there may be slightly *less* than this value. There will never be more.\n     * This cannot be 0 or else it makes it impossible to scroll back in a room.\n     * Default: 50.\n     */\n    maxTimelineEntries?: number;\n}\n\nexport interface IMinimalEvent {\n    content: IContent;\n    type: EventType | string;\n    room_id?: string;\n    unsigned?: IUnsigned;\n}\n\nexport interface IEphemeral {\n    events: IMinimalEvent[];\n}\n\n/* eslint-disable camelcase */\ninterface UnreadNotificationCounts {\n    highlight_count?: number;\n    notification_count?: number;\n}\n\nexport interface IRoomEvent extends IMinimalEvent {\n    event_id: string;\n    sender: string;\n    origin_server_ts: number;\n}\n\nexport interface IStateEvent extends IRoomEvent {\n    prev_content?: IContent;\n    state_key: string;\n}\n\ninterface IState {\n    events: IStateEvent[];\n}\n\nexport interface ITimeline {\n    events: Array<IRoomEvent | IStateEvent>;\n    limited?: boolean;\n    prev_batch: string | null;\n}\n\ntype StickyEventFields = {\n    msc4354_sticky: { duration_ms: number };\n    content: { msc4354_sticky_key?: string };\n};\n\nexport type IStickyEvent = IRoomEvent & StickyEventFields;\n\nexport type IStickyStateEvent = IStateEvent & StickyEventFields;\n\nexport interface ISticky {\n    events: Array<IStickyEvent | IStickyStateEvent>;\n}\n\nexport interface IJoinedRoom {\n    \"summary\": IRoomSummary;\n    // One of `state` or `state_after` is required.\n    \"state\"?: IState;\n    \"org.matrix.msc4222.state_after\"?: IState; // https://github.com/matrix-org/matrix-spec-proposals/pull/4222\n    \"msc4354_sticky\"?: ISticky; // https://github.com/matrix-org/matrix-spec-proposals/pull/4354\n    \"timeline\": ITimeline;\n    \"ephemeral\": IEphemeral;\n    \"account_data\": IAccountData;\n    \"unread_notifications\": UnreadNotificationCounts;\n    \"unread_thread_notifications\"?: Record<string, UnreadNotificationCounts>;\n    \"org.matrix.msc3773.unread_thread_notifications\"?: Record<string, UnreadNotificationCounts>;\n}\n\nexport interface IStrippedState {\n    content: IContent;\n    state_key: string;\n    type: EventType | string;\n    sender: string;\n}\n\nexport interface IInviteState {\n    events: IStrippedState[];\n}\n\nexport interface IKnockState {\n    events: IStrippedState[];\n}\n\nexport interface IInvitedRoom {\n    invite_state: IInviteState;\n}\n\nexport interface ILeftRoom {\n    // One of `state` or `state_after` is required.\n    \"state\"?: IState;\n    \"org.matrix.msc4222.state_after\"?: IState;\n    \"timeline\": ITimeline;\n    \"account_data\": IAccountData;\n}\n\nexport interface IKnockedRoom {\n    knock_state: IKnockState;\n}\n\nexport interface IRooms {\n    [Category.Join]: Record<string, IJoinedRoom>;\n    [Category.Invite]: Record<string, IInvitedRoom>;\n    [Category.Leave]: Record<string, ILeftRoom>;\n    [Category.Knock]: Record<string, IKnockedRoom>;\n}\n\ninterface IPresence {\n    events: IMinimalEvent[];\n}\n\ninterface IAccountData {\n    events: IMinimalEvent[];\n}\n\n/** A to-device message as received from the sync. */\nexport interface IToDeviceEvent {\n    content: IContent;\n    sender: string;\n    type: string;\n}\n\n/**\n * A (possibly decrypted) to-device message after it has been successfully processed by the sdk.\n *\n * If the message was encrypted, the `encryptionInfo` field will contain the encryption information.\n * If the message was sent in clear, this field will be null.\n *\n * The `message` field contains the message `type`, `content`, and `sender` as if the message was sent in clear.\n */\nexport interface ReceivedToDeviceMessage {\n    /** The message type, content, and sender as if the message was sent in clear. */\n    message: IToDeviceEvent;\n    /**\n     * Information about the encryption of the message.\n     * Will be null if the message was sent in clear\n     */\n    encryptionInfo: OlmEncryptionInfo | null;\n}\n\ninterface IToDevice {\n    events: IToDeviceEvent[];\n}\n\nexport interface IDeviceLists {\n    changed?: string[];\n    left?: string[];\n}\n\nexport interface ISyncResponse {\n    \"next_batch\": string;\n    \"rooms\": IRooms;\n    \"presence\"?: IPresence;\n    \"account_data\": IAccountData;\n    \"to_device\"?: IToDevice;\n    \"device_lists\"?: IDeviceLists;\n    \"device_one_time_keys_count\"?: Record<string, number>;\n\n    \"device_unused_fallback_key_types\"?: string[];\n    \"org.matrix.msc2732.device_unused_fallback_key_types\"?: string[];\n}\n/* eslint-enable camelcase */\n\nexport enum Category {\n    Invite = \"invite\",\n    Leave = \"leave\",\n    Join = \"join\",\n    Knock = \"knock\",\n}\n\ninterface IRoom {\n    _currentState: { [eventType: string]: { [stateKey: string]: IStateEvent } };\n    _timeline: {\n        event: IRoomEvent | IStateEvent;\n        token: string | null;\n    }[];\n    _summary: Partial<IRoomSummary>;\n    _accountData: { [eventType: string]: IMinimalEvent };\n    _unreadNotifications: Partial<UnreadNotificationCounts>;\n    _unreadThreadNotifications?: Record<string, Partial<UnreadNotificationCounts>>;\n    _receipts: ReceiptAccumulator;\n    _stickyEvents: {\n        readonly event: IStickyEvent | IStickyStateEvent;\n        /**\n         * This is the timestamp at which point it is safe to remove this event from the store.\n         * This value is immutable\n         */\n        readonly expiresTs: number;\n    }[];\n}\n\nexport interface ISyncData {\n    nextBatch: string;\n    accountData: IMinimalEvent[];\n    roomsData: IRooms;\n}\n\ntype TaggedEvent = IRoomEvent & { _localTs?: number };\n\nfunction isTaggedEvent(event: IRoomEvent): event is TaggedEvent {\n    return \"_localTs\" in event && event[\"_localTs\"] !== undefined;\n}\n\n/**\n * The purpose of this class is to accumulate /sync responses such that a\n * complete \"initial\" JSON response can be returned which accurately represents\n * the sum total of the /sync responses accumulated to date. It only handles\n * room data: that is, everything under the \"rooms\" top-level key.\n *\n * This class is used when persisting room data so a complete /sync response can\n * be loaded from disk and incremental syncs can be performed on the server,\n * rather than asking the server to do an initial sync on startup.\n */\nexport class SyncAccumulator {\n    private accountData: Record<string, IMinimalEvent> = {}; // $event_type: Object\n    private inviteRooms: Record<string, IInvitedRoom> = {}; // $roomId: { ... sync 'invite' json data ... }\n    private knockRooms: Record<string, IKnockedRoom> = {}; // $roomId: { ... sync 'knock' json data ... }\n    private joinRooms: { [roomId: string]: IRoom } = {};\n    // the /sync token which corresponds to the last time rooms were\n    // accumulated. We remember this so that any caller can obtain a\n    // coherent /sync response and know at what point they should be\n    // streaming from without losing events.\n    private nextBatch: string | null = null;\n\n    public constructor(private readonly opts: IOpts = {}) {\n        this.opts.maxTimelineEntries = this.opts.maxTimelineEntries || 50;\n    }\n\n    public accumulate(syncResponse: ISyncResponse, fromDatabase = false): void {\n        this.accumulateRooms(syncResponse, fromDatabase);\n        this.accumulateAccountData(syncResponse);\n        this.nextBatch = syncResponse.next_batch;\n    }\n\n    private accumulateAccountData(syncResponse: ISyncResponse): void {\n        if (!syncResponse.account_data || !syncResponse.account_data.events) {\n            return;\n        }\n        // Clobbers based on event type.\n        syncResponse.account_data.events.forEach((e) => {\n            this.accountData[e.type] = e;\n        });\n    }\n\n    /**\n     * Accumulate incremental /sync room data.\n     * @param syncResponse - the complete /sync JSON\n     * @param fromDatabase - True if the sync response is one saved to the database\n     */\n    private accumulateRooms(syncResponse: ISyncResponse, fromDatabase = false): void {\n        if (!syncResponse.rooms) {\n            return;\n        }\n        if (syncResponse.rooms.invite) {\n            Object.keys(syncResponse.rooms.invite).forEach((roomId) => {\n                this.accumulateRoom(roomId, Category.Invite, syncResponse.rooms.invite[roomId], fromDatabase);\n            });\n        }\n        if (syncResponse.rooms.join) {\n            Object.keys(syncResponse.rooms.join).forEach((roomId) => {\n                this.accumulateRoom(roomId, Category.Join, syncResponse.rooms.join[roomId], fromDatabase);\n            });\n        }\n        if (syncResponse.rooms.leave) {\n            Object.keys(syncResponse.rooms.leave).forEach((roomId) => {\n                this.accumulateRoom(roomId, Category.Leave, syncResponse.rooms.leave[roomId], fromDatabase);\n            });\n        }\n        if (syncResponse.rooms.knock) {\n            Object.keys(syncResponse.rooms.knock).forEach((roomId) => {\n                this.accumulateRoom(roomId, Category.Knock, syncResponse.rooms.knock[roomId], fromDatabase);\n            });\n        }\n    }\n\n    private accumulateRoom(roomId: string, category: Category.Invite, data: IInvitedRoom, fromDatabase: boolean): void;\n    private accumulateRoom(roomId: string, category: Category.Join, data: IJoinedRoom, fromDatabase: boolean): void;\n    private accumulateRoom(roomId: string, category: Category.Leave, data: ILeftRoom, fromDatabase: boolean): void;\n    private accumulateRoom(roomId: string, category: Category.Knock, data: IKnockedRoom, fromDatabase: boolean): void;\n    private accumulateRoom(roomId: string, category: Category, data: any, fromDatabase = false): void {\n        // Valid /sync state transitions\n        //       +--------+ <======+            1: Accept an invite\n        //   +== | INVITE |        | (5)        2: Leave a room\n        //   |   +--------+ =====+ |            3: Join a public room previously\n        //   |(1)            (4) | |               left (handle as if new room)\n        //   V         (2)       V |            4: Reject an invite\n        // +------+ ========> +--------+         5: Invite to a room previously\n        // | JOIN |    (3)    | LEAVE* |            left (handle as if new room)\n        // +------+ <======== +--------+\n        //\n        // * equivalent to \"no state\"\n        switch (category) {\n            case Category.Invite: // (5)\n                if (this.knockRooms[roomId]) {\n                    // was previously knock, now invite, need to delete knock state\n                    delete this.knockRooms[roomId];\n                }\n                this.accumulateInviteState(roomId, data as IInvitedRoom);\n                break;\n\n            case Category.Knock:\n                this.accumulateKnockState(roomId, data as IKnockedRoom);\n                break;\n\n            case Category.Join:\n                if (this.knockRooms[roomId]) {\n                    // delete knock state on join\n                    delete this.knockRooms[roomId];\n                } else if (this.inviteRooms[roomId]) {\n                    // (1)\n                    // was previously invite, now join. We expect /sync to give\n                    // the entire state and timeline on 'join', so delete previous\n                    // invite state\n                    delete this.inviteRooms[roomId];\n                }\n                // (3)\n                this.accumulateJoinState(roomId, data as IJoinedRoom, fromDatabase);\n                break;\n\n            case Category.Leave:\n                if (this.knockRooms[roomId]) {\n                    // delete knock state on leave\n                    delete this.knockRooms[roomId];\n                } else if (this.inviteRooms[roomId]) {\n                    // (4)\n                    delete this.inviteRooms[roomId];\n                } else {\n                    // (2)\n                    delete this.joinRooms[roomId];\n                }\n                break;\n\n            default:\n                logger.error(\"Unknown cateogory: \", category);\n        }\n    }\n\n    private accumulateInviteState(roomId: string, data: IInvitedRoom): void {\n        if (!data.invite_state || !data.invite_state.events) {\n            // no new data\n            return;\n        }\n        if (!this.inviteRooms[roomId]) {\n            this.inviteRooms[roomId] = {\n                invite_state: data.invite_state,\n            };\n            return;\n        }\n        // accumulate extra keys for invite->invite transitions\n        // clobber based on event type / state key\n        // We expect invite_state to be small, so just loop over the events\n        const currentData = this.inviteRooms[roomId];\n        data.invite_state.events.forEach((e) => {\n            let hasAdded = false;\n            for (let i = 0; i < currentData.invite_state.events.length; i++) {\n                const current = currentData.invite_state.events[i];\n                if (current.type === e.type && current.state_key == e.state_key) {\n                    currentData.invite_state.events[i] = e; // update\n                    hasAdded = true;\n                }\n            }\n            if (!hasAdded) {\n                currentData.invite_state.events.push(e);\n            }\n        });\n    }\n\n    private accumulateKnockState(roomId: string, data: IKnockedRoom): void {\n        if (!data.knock_state || !data.knock_state.events) {\n            // no new data\n            return;\n        }\n        if (!this.knockRooms[roomId]) {\n            this.knockRooms[roomId] = {\n                knock_state: data.knock_state,\n            };\n            return;\n        }\n        // accumulate extra keys\n        // clobber based on event type / state key\n        // We expect knock_state to be small, so just loop over the events\n        const currentData = this.knockRooms[roomId];\n        data.knock_state.events.forEach((e) => {\n            let hasAdded = false;\n            for (let i = 0; i < currentData.knock_state.events.length; i++) {\n                const current = currentData.knock_state.events[i];\n                if (current.type === e.type && current.state_key == e.state_key) {\n                    currentData.knock_state.events[i] = e; // update\n                    hasAdded = true;\n                }\n            }\n            if (!hasAdded) {\n                currentData.knock_state.events.push(e);\n            }\n        });\n    }\n\n    // Accumulate timeline and state events in a room.\n    private accumulateJoinState(roomId: string, data: IJoinedRoom, fromDatabase = false): void {\n        const now = Date.now();\n        // We expect this function to be called a lot (every /sync) so we want\n        // this to be fast. /sync stores events in an array but we often want\n        // to clobber based on type/state_key. Rather than convert arrays to\n        // maps all the time, just keep private maps which contain\n        // the actual current accumulated sync state, and array-ify it when\n        // getJSON() is called.\n\n        // State resolution:\n        // The 'state' key is the delta from the previous sync (or start of time\n        // if no token was supplied), to the START of the timeline. To obtain\n        // the current state, we need to \"roll forward\" state by reading the\n        // timeline. We want to store the current state so we can drop events\n        // out the end of the timeline based on opts.maxTimelineEntries.\n        //\n        //      'state'     'timeline'     current state\n        // |-------x<======================>x\n        //          T   I   M   E\n        //\n        // When getJSON() is called, we 'roll back' the current state by the\n        // number of entries in the timeline to work out what 'state' should be.\n\n        // Back-pagination:\n        // On an initial /sync, the server provides a back-pagination token for\n        // the start of the timeline. When /sync deltas come down, they also\n        // include back-pagination tokens for the start of the timeline. This\n        // means not all events in the timeline have back-pagination tokens, as\n        // it is only the ones at the START of the timeline which have them.\n        // In order for us to have a valid timeline (and back-pagination token\n        // to match), we need to make sure that when we remove old timeline\n        // events, that we roll forward to an event which has a back-pagination\n        // token. This means we can't keep a strict sliding-window based on\n        // opts.maxTimelineEntries, and we may have a few less. We should never\n        // have more though, provided that the /sync limit is less than or equal\n        // to opts.maxTimelineEntries.\n\n        if (!this.joinRooms[roomId]) {\n            // Create truly empty objects so event types of 'hasOwnProperty' and co\n            // don't cause this code to break.\n            this.joinRooms[roomId] = {\n                _currentState: Object.create(null),\n                _timeline: [],\n                _accountData: Object.create(null),\n                _unreadNotifications: {},\n                _unreadThreadNotifications: {},\n                _summary: {},\n                _receipts: new ReceiptAccumulator(),\n                _stickyEvents: [],\n            };\n        }\n        const currentData = this.joinRooms[roomId];\n\n        if (data.account_data && data.account_data.events) {\n            // clobber based on type\n            data.account_data.events.forEach((e) => {\n                currentData._accountData[e.type] = e;\n            });\n        }\n\n        // these probably clobber, spec is unclear.\n        if (data.unread_notifications) {\n            currentData._unreadNotifications = data.unread_notifications;\n        }\n        currentData._unreadThreadNotifications =\n            data[UNREAD_THREAD_NOTIFICATIONS.stable!] ?? data[UNREAD_THREAD_NOTIFICATIONS.unstable!] ?? undefined;\n\n        if (data.summary) {\n            const HEROES_KEY = \"m.heroes\";\n            const INVITED_COUNT_KEY = \"m.invited_member_count\";\n            const JOINED_COUNT_KEY = \"m.joined_member_count\";\n\n            const acc = currentData._summary;\n            const sum = data.summary;\n            acc[HEROES_KEY] = sum[HEROES_KEY] ?? acc[HEROES_KEY];\n            acc[JOINED_COUNT_KEY] = sum[JOINED_COUNT_KEY] ?? acc[JOINED_COUNT_KEY];\n            acc[INVITED_COUNT_KEY] = sum[INVITED_COUNT_KEY] ?? acc[INVITED_COUNT_KEY];\n        }\n\n        // We purposefully do not persist m.typing events.\n        // Technically you could refresh a browser before the timer on a\n        // typing event is up, so it'll look like you aren't typing when\n        // you really still are. However, the alternative is worse. If\n        // we do persist typing events, it will look like people are\n        // typing forever until someone really does start typing (which\n        // will prompt Synapse to send down an actual m.typing event to\n        // clobber the one we persisted).\n\n        // Persist the receipts\n        currentData._receipts.consumeEphemeralEvents(data.ephemeral?.events);\n\n        // if we got a limited sync, we need to remove all timeline entries or else\n        // we will have gaps in the timeline.\n        if (data.timeline && data.timeline.limited) {\n            currentData._timeline = [];\n        }\n\n        // Work out the current state. The deltas need to be applied in the order:\n        // - existing state which didn't come down /sync.\n        // - State events under the 'state' key.\n        // - State events under the 'state_after' key OR state events in the 'timeline' if 'state_after' is not present.\n        data.state?.events?.forEach((e) => {\n            setState(currentData._currentState, e);\n        });\n        data[\"org.matrix.msc4222.state_after\"]?.events?.forEach((e) => {\n            setState(currentData._currentState, e);\n        });\n        data.timeline?.events?.forEach((e, index) => {\n            if (!data[\"org.matrix.msc4222.state_after\"]) {\n                // this nops if 'e' isn't a state event\n                setState(currentData._currentState, e);\n            }\n            // append the event to the timeline. The back-pagination token\n            // corresponds to the first event in the timeline\n            let transformedEvent: TaggedEvent;\n            if (!fromDatabase) {\n                transformedEvent = Object.assign({}, e);\n                if (transformedEvent.unsigned !== undefined) {\n                    transformedEvent.unsigned = Object.assign({}, transformedEvent.unsigned);\n                }\n                const age = e.unsigned?.age;\n                if (age !== undefined) transformedEvent._localTs = Date.now() - age;\n            } else {\n                transformedEvent = e;\n            }\n\n            currentData._timeline.push({\n                event: transformedEvent,\n                token: index === 0 ? (data.timeline.prev_batch ?? null) : null,\n            });\n        });\n\n        // Prune out any events in our stores that have since expired, do this before we\n        // insert new events.\n        currentData._stickyEvents = currentData._stickyEvents.filter(({ expiresTs }) => expiresTs > now);\n\n        // We want this to be fast, so don't worry about duplicate events here. The RoomStickyEventsStore will\n        // process these events into the correct mapped order.\n        if (data.msc4354_sticky?.events) {\n            currentData._stickyEvents = currentData._stickyEvents.concat(\n                data.msc4354_sticky.events.map((event) => {\n                    // If `duration_ms` exceeds the spec limit of a hour, we cap it.\n                    const cappedDuration = Math.min(event.msc4354_sticky.duration_ms, MAX_STICKY_DURATION_MS);\n                    // If `origin_server_ts` claims to have been from the future, we still bound it to now.\n                    const createdTs = Math.min(event.origin_server_ts, now);\n                    return {\n                        event,\n                        expiresTs: cappedDuration + createdTs,\n                    };\n                }),\n            );\n        }\n\n        // attempt to prune the timeline by jumping between events which have\n        // pagination tokens.\n        if (currentData._timeline.length > this.opts.maxTimelineEntries!) {\n            const startIndex = currentData._timeline.length - this.opts.maxTimelineEntries!;\n            for (let i = startIndex; i < currentData._timeline.length; i++) {\n                if (currentData._timeline[i].token) {\n                    // keep all events after this, including this one\n                    currentData._timeline = currentData._timeline.slice(i, currentData._timeline.length);\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * Return everything under the 'rooms' key from a /sync response which\n     * represents all room data that should be stored. This should be paired\n     * with the sync token which represents the most recent /sync response\n     * provided to accumulate().\n     * @param forDatabase - True to generate a sync to be saved to storage\n     * @returns An object with a \"nextBatch\", \"roomsData\" and \"accountData\"\n     * keys.\n     * The \"nextBatch\" key is a string which represents at what point in the\n     * /sync stream the accumulator reached. This token should be used when\n     * restarting a /sync stream at startup. Failure to do so can lead to missing\n     * events. The \"roomsData\" key is an Object which represents the entire\n     * /sync response from the 'rooms' key onwards. The \"accountData\" key is\n     * a list of raw events which represent global account data.\n     */\n    public getJSON(forDatabase = false): ISyncData {\n        const data: IRooms = {\n            join: {},\n            invite: {},\n            knock: {},\n            // always empty. This is set by /sync when a room was previously\n            // in 'invite' or 'join'. On fresh startup, the client won't know\n            // about any previous room being in 'invite' or 'join' so we can\n            // just omit mentioning it at all, even if it has previously come\n            // down /sync.\n            // The notable exception is when a client is kicked or banned:\n            // we may want to hold onto that room so the client can clearly see\n            // why their room has disappeared. We don't persist it though because\n            // it is unclear *when* we can safely remove the room from the DB.\n            // Instead, we assume that if you're loading from the DB, you've\n            // refreshed the page, which means you've seen the kick/ban already.\n            leave: {},\n        };\n        Object.keys(this.inviteRooms).forEach((roomId) => {\n            data.invite[roomId] = this.inviteRooms[roomId];\n        });\n        Object.keys(this.knockRooms).forEach((roomId) => {\n            data.knock[roomId] = this.knockRooms[roomId];\n        });\n        Object.keys(this.joinRooms).forEach((roomId) => {\n            const roomData = this.joinRooms[roomId];\n            const roomJson: IJoinedRoom & {\n                // We track both `state` and `state_after` for downgrade compatibility\n                \"state\": IState;\n                \"org.matrix.msc4222.state_after\": IState;\n            } = {\n                \"ephemeral\": { events: [] },\n                \"account_data\": { events: [] },\n                \"state\": { events: [] },\n                \"org.matrix.msc4222.state_after\": { events: [] },\n                \"timeline\": {\n                    events: [],\n                    prev_batch: null,\n                },\n                \"unread_notifications\": roomData._unreadNotifications,\n                \"unread_thread_notifications\": roomData._unreadThreadNotifications,\n                \"summary\": roomData._summary as IRoomSummary,\n                \"msc4354_sticky\": roomData._stickyEvents?.length\n                    ? {\n                          events: roomData._stickyEvents.map((e) => e.event),\n                      }\n                    : undefined,\n            };\n            // Add account data\n            Object.keys(roomData._accountData).forEach((evType) => {\n                roomJson.account_data.events.push(roomData._accountData[evType]);\n            });\n\n            const receiptEvent = roomData._receipts.buildAccumulatedReceiptEvent(roomId);\n\n            // add only if we have some receipt data\n            if (receiptEvent) {\n                roomJson.ephemeral.events.push(receiptEvent);\n            }\n\n            // Add timeline data\n            roomData._timeline.forEach((msgData) => {\n                if (!roomJson.timeline.prev_batch) {\n                    // the first event we add to the timeline MUST match up to\n                    // the prev_batch token.\n                    if (!msgData.token) {\n                        return; // this shouldn't happen as we prune constantly.\n                    }\n                    roomJson.timeline.prev_batch = msgData.token;\n                }\n\n                let transformedEvent: (IRoomEvent | IStateEvent) & { _localTs?: number };\n                if (!forDatabase && isTaggedEvent(msgData.event)) {\n                    // This means we have to copy each event, so we can fix it up to\n                    // set a correct 'age' parameter whilst keeping the local timestamp\n                    // on our stored event. If this turns out to be a bottleneck, it could\n                    // be optimised either by doing this in the main process after the data\n                    // has been structured-cloned to go between the worker & main process,\n                    // or special-casing data from saved syncs to read the local timestamp\n                    // directly rather than turning it into age to then immediately be\n                    // transformed back again into a local timestamp.\n                    transformedEvent = Object.assign({}, msgData.event);\n                    if (transformedEvent.unsigned !== undefined) {\n                        transformedEvent.unsigned = Object.assign({}, transformedEvent.unsigned);\n                    }\n                    delete transformedEvent._localTs;\n                    transformedEvent.unsigned = transformedEvent.unsigned || {};\n                    transformedEvent.unsigned.age = Date.now() - msgData.event._localTs!;\n                } else {\n                    transformedEvent = msgData.event;\n                }\n                roomJson.timeline.events.push(transformedEvent);\n            });\n\n            // Add state data: roll back current state to the start of timeline,\n            // by \"reverse clobbering\" from the end of the timeline to the start.\n            // Convert maps back into arrays.\n            const rollBackState = Object.create(null);\n            for (let i = roomJson.timeline.events.length - 1; i >= 0; i--) {\n                const timelineEvent = roomJson.timeline.events[i];\n                if (\n                    (timelineEvent as IStateEvent).state_key === null ||\n                    (timelineEvent as IStateEvent).state_key === undefined\n                ) {\n                    continue; // not a state event\n                }\n                // since we're going back in time, we need to use the previous\n                // state value else we'll break causality. We don't have the\n                // complete previous state event, so we need to create one.\n                const prevStateEvent = deepCopy(timelineEvent);\n                if (prevStateEvent.unsigned) {\n                    if (prevStateEvent.unsigned.prev_content) {\n                        prevStateEvent.content = prevStateEvent.unsigned.prev_content;\n                    }\n                    if (prevStateEvent.unsigned.prev_sender) {\n                        prevStateEvent.sender = prevStateEvent.unsigned.prev_sender;\n                    }\n                }\n                setState(rollBackState, prevStateEvent);\n            }\n            Object.keys(roomData._currentState).forEach((evType) => {\n                Object.keys(roomData._currentState[evType]).forEach((stateKey) => {\n                    let ev = roomData._currentState[evType][stateKey];\n                    // Push to both fields to provide downgrade compatibility in the sync accumulator db\n                    // the code will prefer `state_after` if it is present\n                    roomJson[\"org.matrix.msc4222.state_after\"].events.push(ev);\n                    // Roll the state back to the value at the start of the timeline if it was changed\n                    if (rollBackState[evType] && rollBackState[evType][stateKey]) {\n                        ev = rollBackState[evType][stateKey];\n                    }\n                    roomJson.state.events.push(ev);\n                });\n            });\n            data.join[roomId] = roomJson;\n        });\n\n        // Add account data\n        const accData: IMinimalEvent[] = [];\n        Object.keys(this.accountData).forEach((evType) => {\n            accData.push(this.accountData[evType]);\n        });\n\n        return {\n            nextBatch: this.nextBatch!,\n            roomsData: data,\n            accountData: accData,\n        };\n    }\n\n    public getNextBatchToken(): string {\n        return this.nextBatch!;\n    }\n}\n\nfunction setState(eventMap: Record<string, Record<string, IStateEvent>>, event: IRoomEvent | IStateEvent): void {\n    if ((event as IStateEvent).state_key === null || (event as IStateEvent).state_key === undefined || !event.type) {\n        return;\n    }\n    if (!eventMap[event.type]) {\n        eventMap[event.type] = Object.create(null);\n    }\n    eventMap[event.type][(event as IStateEvent).state_key] = event as IStateEvent;\n}\n"],"mappings":"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","ignoreList":[]}