{"version":3,"file":"backup.js","names":["RustSdkCryptoJs","ClientPrefix","MatrixError","Method","TypedEventEmitter","encodeUri","logDuration","sleep","CryptoEvent","ImportRoomKeyStage","RustBackupManager","constructor","logger","olmMachine","http","outgoingRequestProcessor","_defineProperty","undefined","stop","stopped","getActiveBackupVersion","_this","_asyncToGenerator","isBackupEnabled","activeBackupVersion","getServerBackupInfo","_this2","checkKeyBackupAndEnable","serverBackupInfo","isKeyBackupTrusted","info","_this3","signatureVerification","verifyBackup","backupKeys","getBackupKeys","decryptionKey","backupMatchesSavedPrivateKey","backupInfoMatchesBackupDecryptionKey","matchesDecryptionKey","trusted","force","checkedForBackup","Promise","resolve","keyBackupCheckInProgress","doCheckKeyBackup","finally","handleBackupSecretReceived","secret","_this4","_latestBackupInfo","latestBackupInfo","requestKeyBackupVersion","e","warn","version","backupDecryptionKey","BackupDecryptionKey","fromBase64","privateKeyMatches","saveBackupDecryptionKey","_this5","emit","KeyBackupDecryptionKeyCached","importRoomKeys","keys","opts","_this6","importRoomKeysAsJson","JSON","stringify","jsonKeys","_this7","importExportedRoomKeys","progress","total","_opts$progressCallbac","importOpt","Number","successes","stage","LoadKeys","failures","progressCallback","call","importBackedUpRoomKeys","backupVersion","_this8","keysByRoom","Map","key","roomId","RoomId","room_id","has","set","get","session_id","_opts$progressCallbac2","_this9","debug","backupInfo","activeVersion","disableKeyBackup","trustInfo","concat","enableKeyBackup","_this0","enableBackupV1","auth_data","public_key","KeyBackupStatus","backupKeysLoop","maybeUploadKey","_this1","_this10","disableBackup","_arguments","arguments","_this11","maxDelay","length","backupKeysLoopRunning","delay","Math","random","numFailures","remainingToUploadCount","isFirstIteration","request","backupRoomKeys","err","error","KeyBackupSessionsRemaining","makeOutgoingRequest","keyCount","roomKeyCounts","backedUp","keysCountInBatch","max","errCode","data","errcode","KeyBackupFailed","isRateLimitError","waitTime","getRetryAfterMs","pow","min","batch","parsedBody","parse","body","countKeysInBackup","_this12","setupKeyBackup","signObject","_this13","deleteAllKeyBackupVersions","randomKey","createRandomKey","pubKey","megolmV1PublicKey","authData","publicKeyBase64","res","authedRequest","Post","algorithm","prefix","V3","_this14","_yield$_this14$reques","_yield$_this14$reques2","current","_yield$_this14$reques3","_yield$_this14$reques4","deleteKeyBackupVersion","_this15","path","$version","Delete","createBackupDecryptor","RustBackupDecryptor","restoreKeyBackup","backupDecryptor","_this16","keyBackup","downloadKeyBackup","importKeyBackup","Get","_this17","_opts$progressCallbac3","CHUNK_SIZE","totalKeyCount","totalImported","totalFailures","handleChunkCallback","_ref2","roomChunks","_opts$progressCallbac4","currentChunk","_loop","decryptedSessions","decryptSessions","forEach","session","push","_x","apply","groupChunkCount","chunkGroupByRoom","roomData","Object","entries","rooms","sessions","sessionId","sessionsForRoom","imported","_info$auth_data","sourceTrusted","ciphertexts","_this18","sessionData","decrypted","decryptV1","session_data","ephemeral","mac","ciphertext","free","_x2","_x3","_requestKeyBackupVersion","decryptionKeyMatchesKeyBackupInfo","keyBackupInfo","count","values"],"sources":["../../src/rust-crypto/backup.ts"],"sourcesContent":["/*\nCopyright 2023 - 2024 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type OlmMachine, type SignatureVerification } from \"@matrix-org/matrix-sdk-crypto-wasm\";\nimport * as RustSdkCryptoJs from \"@matrix-org/matrix-sdk-crypto-wasm\";\n\nimport {\n    type BackupTrustInfo,\n    type Curve25519AuthData,\n    type KeyBackupCheck,\n    type KeyBackupInfo,\n    type KeyBackupSession,\n    type Curve25519SessionData,\n    type KeyBackupRestoreOpts,\n    type KeyBackupRestoreResult,\n    type KeyBackupRoomSessions,\n} from \"../crypto-api/keybackup.ts\";\nimport { type Logger } from \"../logger.ts\";\nimport { ClientPrefix, type IHttpOpts, MatrixError, type MatrixHttpApi, Method } from \"../http-api/index.ts\";\nimport { TypedEventEmitter } from \"../models/typed-event-emitter.ts\";\nimport { encodeUri, logDuration } from \"../utils.ts\";\nimport { type OutgoingRequestProcessor } from \"./OutgoingRequestProcessor.ts\";\nimport { sleep } from \"../utils.ts\";\nimport { type BackupDecryptor } from \"../common-crypto/CryptoBackend.ts\";\nimport {\n    type ImportRoomKeyProgressData,\n    type ImportRoomKeysOpts,\n    CryptoEvent,\n    ImportRoomKeyStage,\n} from \"../crypto-api/index.ts\";\nimport { type AESEncryptedSecretStoragePayload } from \"../@types/AESEncryptedSecretStoragePayload.ts\";\nimport { type IMegolmSessionData } from \"../@types/crypto.ts\";\n\n/** Authentification of the backup info, depends on algorithm */\ntype AuthData = KeyBackupInfo[\"auth_data\"];\n\n/**\n * Holds information of a created keybackup.\n * Useful to get the generated private key material and save it securely somewhere.\n */\ninterface KeyBackupCreationInfo {\n    version: string;\n    algorithm: string;\n    authData: AuthData;\n    decryptionKey: RustSdkCryptoJs.BackupDecryptionKey;\n}\n\n/**\n * @internal\n */\nexport class RustBackupManager extends TypedEventEmitter<RustBackupCryptoEvents, RustBackupCryptoEventMap> {\n    /** Have we checked if there is a backup on the server which we can use */\n    private checkedForBackup = false;\n\n    /**\n     * The latest backup version on the server, when we last checked.\n     *\n     * If there was no backup on the server, `null`. If our attempt to check resulted in an error, `undefined`.\n     *\n     * Note that the backup was not necessarily verified.\n     */\n    private serverBackupInfo: KeyBackupInfo | null | undefined = undefined;\n\n    private activeBackupVersion: string | null = null;\n    private stopped = false;\n\n    /** whether {@link backupKeysLoop} is currently running */\n    private backupKeysLoopRunning = false;\n\n    public constructor(\n        private readonly logger: Logger,\n        private readonly olmMachine: OlmMachine,\n        private readonly http: MatrixHttpApi<IHttpOpts & { onlyData: true }>,\n        private readonly outgoingRequestProcessor: OutgoingRequestProcessor,\n    ) {\n        super();\n    }\n\n    /**\n     * Tells the RustBackupManager to stop.\n     * The RustBackupManager is scheduling background uploads of keys to the backup, this\n     * call allows to cancel the process when the client is stoppped.\n     */\n    public stop(): void {\n        this.stopped = true;\n    }\n\n    /**\n     * Get the backup version we are currently backing up to, if any\n     */\n    public async getActiveBackupVersion(): Promise<string | null> {\n        if (!(await this.olmMachine.isBackupEnabled())) return null;\n        return this.activeBackupVersion;\n    }\n\n    /**\n     * Return the details of the latest backup on the server, when we last checked.\n     *\n     * This normally returns a cached value, but if we haven't yet made a request to the server, it will fire one off.\n     * It will always return the details of the active backup if key backup is enabled.\n     *\n     * If there was no backup on the server, `null`. If our attempt to check resulted in an error, `undefined`.\n     */\n    public async getServerBackupInfo(): Promise<KeyBackupInfo | null | undefined> {\n        // Do a validity check if we haven't already done one. The check is likely to fail if we don't yet have the\n        // backup keys -- but as a side-effect, it will populate `serverBackupInfo`.\n        await this.checkKeyBackupAndEnable(false);\n        return this.serverBackupInfo;\n    }\n\n    /**\n     * Determine if a key backup can be trusted.\n     *\n     * @param info - key backup info dict from {@link CryptoApi.getKeyBackupInfo}.\n     */\n    public async isKeyBackupTrusted(info: KeyBackupInfo): Promise<BackupTrustInfo> {\n        const signatureVerification: SignatureVerification = await this.olmMachine.verifyBackup(info);\n\n        const backupKeys: RustSdkCryptoJs.BackupKeys = await this.olmMachine.getBackupKeys();\n        const decryptionKey = backupKeys?.decryptionKey;\n        const backupMatchesSavedPrivateKey =\n            !!decryptionKey && this.backupInfoMatchesBackupDecryptionKey(info, decryptionKey);\n        return {\n            matchesDecryptionKey: backupMatchesSavedPrivateKey,\n            trusted: signatureVerification.trusted(),\n        };\n    }\n\n    /**\n     * Re-check the key backup and enable/disable it as appropriate.\n     *\n     * @param force - whether we should force a re-check even if one has already happened.\n     */\n    public checkKeyBackupAndEnable(force: boolean): Promise<KeyBackupCheck | null> {\n        if (!force && this.checkedForBackup) {\n            return Promise.resolve(null);\n        }\n\n        // make sure there is only one check going on at a time\n        if (!this.keyBackupCheckInProgress) {\n            this.keyBackupCheckInProgress = this.doCheckKeyBackup().finally(() => {\n                this.keyBackupCheckInProgress = null;\n            });\n        }\n        return this.keyBackupCheckInProgress;\n    }\n\n    /**\n     * Handles a backup secret received event and store it if it matches the current backup version.\n     *\n     * @param secret - The secret as received from a `m.secret.send` event for secret `m.megolm_backup.v1`.\n     * @returns true if the secret is valid and has been stored, false otherwise.\n     */\n    public async handleBackupSecretReceived(secret: string): Promise<boolean> {\n        // Currently we only receive the decryption key without any key backup version. It is important to\n        // check that the secret is valid for the current version before storing it.\n        // We force a check to ensure to have the latest version.\n        let latestBackupInfo: KeyBackupInfo | null;\n        try {\n            latestBackupInfo = await this.requestKeyBackupVersion();\n        } catch (e) {\n            this.logger.warn(\"handleBackupSecretReceived: Error checking for latest key backup\", e);\n            return false;\n        }\n\n        if (!latestBackupInfo?.version) {\n            // There is no server-side key backup.\n            // This decryption key is useless to us.\n            this.logger.warn(\n                \"handleBackupSecretReceived: Received a backup decryption key, but there is no trusted server-side key backup\",\n            );\n            return false;\n        }\n\n        try {\n            const backupDecryptionKey = RustSdkCryptoJs.BackupDecryptionKey.fromBase64(secret);\n            const privateKeyMatches = this.backupInfoMatchesBackupDecryptionKey(latestBackupInfo, backupDecryptionKey);\n            if (!privateKeyMatches) {\n                this.logger.warn(\n                    `handleBackupSecretReceived: Private decryption key does not match the public key of the current remote backup.`,\n                );\n                // just ignore the secret\n                return false;\n            }\n            this.logger.info(\n                `handleBackupSecretReceived: A valid backup decryption key has been received and stored in cache.`,\n            );\n            await this.saveBackupDecryptionKey(backupDecryptionKey, latestBackupInfo.version);\n            return true;\n        } catch (e) {\n            this.logger.warn(\"handleBackupSecretReceived: Invalid backup decryption key\", e);\n        }\n\n        return false;\n    }\n\n    public async saveBackupDecryptionKey(\n        backupDecryptionKey: RustSdkCryptoJs.BackupDecryptionKey,\n        version: string,\n    ): Promise<void> {\n        await this.olmMachine.saveBackupDecryptionKey(backupDecryptionKey, version);\n        // Emit an event that we have a new backup decryption key, so that the sdk can start\n        // importing keys from backup if needed.\n        this.emit(CryptoEvent.KeyBackupDecryptionKeyCached, version);\n    }\n\n    /**\n     * Import a list of room keys previously exported by exportRoomKeys\n     *\n     * @param keys - a list of session export objects\n     * @param opts - options object\n     * @returns a promise which resolves once the keys have been imported\n     */\n    public async importRoomKeys(keys: IMegolmSessionData[], opts?: ImportRoomKeysOpts): Promise<void> {\n        await this.importRoomKeysAsJson(JSON.stringify(keys), opts);\n    }\n\n    /**\n     * Import a list of room keys previously exported by exportRoomKeysAsJson\n     *\n     * @param jsonKeys - a JSON string encoding a list of session export objects,\n     *    each of which is an IMegolmSessionData\n     * @param opts - options object\n     * @returns a promise which resolves once the keys have been imported\n     */\n    public async importRoomKeysAsJson(jsonKeys: string, opts?: ImportRoomKeysOpts): Promise<void> {\n        await this.olmMachine.importExportedRoomKeys(jsonKeys, (progress: bigint, total: bigint): void => {\n            const importOpt: ImportRoomKeyProgressData = {\n                total: Number(total),\n                successes: Number(progress),\n                stage: ImportRoomKeyStage.LoadKeys,\n                failures: 0,\n            };\n            opts?.progressCallback?.(importOpt);\n        });\n    }\n\n    /**\n     * Implementation of {@link CryptoBackend#importBackedUpRoomKeys}.\n     */\n    public async importBackedUpRoomKeys(\n        keys: IMegolmSessionData[],\n        backupVersion: string,\n        opts?: ImportRoomKeysOpts,\n    ): Promise<void> {\n        const keysByRoom: Map<RustSdkCryptoJs.RoomId, Map<string, IMegolmSessionData>> = new Map();\n        for (const key of keys) {\n            const roomId = new RustSdkCryptoJs.RoomId(key.room_id);\n            if (!keysByRoom.has(roomId)) {\n                keysByRoom.set(roomId, new Map());\n            }\n            keysByRoom.get(roomId)!.set(key.session_id, key);\n        }\n        await this.olmMachine.importBackedUpRoomKeys(\n            keysByRoom,\n            (progress: bigint, total: bigint, failures: bigint): void => {\n                const importOpt: ImportRoomKeyProgressData = {\n                    total: Number(total),\n                    successes: Number(progress),\n                    stage: ImportRoomKeyStage.LoadKeys,\n                    failures: Number(failures),\n                };\n                opts?.progressCallback?.(importOpt);\n            },\n            backupVersion,\n        );\n    }\n\n    private keyBackupCheckInProgress: Promise<KeyBackupCheck | null> | null = null;\n\n    /** Helper for `checkKeyBackup` */\n    private async doCheckKeyBackup(): Promise<KeyBackupCheck | null> {\n        this.logger.debug(\"Checking key backup status...\");\n        let backupInfo: KeyBackupInfo | null | undefined;\n        try {\n            backupInfo = await this.requestKeyBackupVersion();\n        } catch (e) {\n            this.logger.warn(\"Error checking for active key backup\", e);\n            this.serverBackupInfo = undefined;\n            return null;\n        }\n        this.checkedForBackup = true;\n\n        if (backupInfo && !backupInfo.version) {\n            this.logger.warn(\"active backup lacks a useful 'version'; ignoring it\");\n            backupInfo = undefined;\n        }\n        this.serverBackupInfo = backupInfo;\n\n        const activeVersion = await this.getActiveBackupVersion();\n\n        if (!backupInfo) {\n            if (activeVersion !== null) {\n                this.logger.debug(\"No key backup present on server: disabling key backup\");\n                await this.disableKeyBackup();\n            } else {\n                this.logger.debug(\"No key backup present on server: not enabling key backup\");\n            }\n            return null;\n        }\n\n        const trustInfo = await this.isKeyBackupTrusted(backupInfo);\n\n        // Per the spec, we should enable key upload if either (a) the backup is signed by a trusted key, or\n        // (b) the public key matches the private decryption key that we have received from 4S.\n        if (!trustInfo.matchesDecryptionKey && !trustInfo.trusted) {\n            if (activeVersion !== null) {\n                this.logger.debug(\"Key backup present on server but not trusted: disabling key backup\");\n                await this.disableKeyBackup();\n            } else {\n                this.logger.debug(\"Key backup present on server but not trusted: not enabling key backup\");\n            }\n        } else {\n            if (activeVersion === null) {\n                this.logger.debug(`Found usable key backup v${backupInfo.version}: enabling key backups`);\n                await this.enableKeyBackup(backupInfo);\n            } else if (activeVersion !== backupInfo.version) {\n                this.logger.debug(\n                    `On backup version ${activeVersion} but found version ${backupInfo.version}: switching.`,\n                );\n                // This will remove any pending backup request, remove the backup key and reset the backup state of each room key we have.\n                await this.disableKeyBackup();\n                // Enabling will now trigger re-upload of all the keys\n                await this.enableKeyBackup(backupInfo);\n            } else {\n                this.logger.debug(`Backup version ${backupInfo.version} still current`);\n            }\n        }\n        return { backupInfo, trustInfo };\n    }\n\n    private async enableKeyBackup(backupInfo: KeyBackupInfo): Promise<void> {\n        // we know for certain it must be a Curve25519 key, because we have verified it and only Curve25519\n        // keys can be verified.\n        //\n        // we also checked it has a valid `version`.\n        await this.olmMachine.enableBackupV1(\n            (backupInfo.auth_data as Curve25519AuthData).public_key,\n            backupInfo.version!,\n        );\n        this.activeBackupVersion = backupInfo.version!;\n\n        this.emit(CryptoEvent.KeyBackupStatus, true);\n\n        this.backupKeysLoop();\n    }\n\n    /**\n     * Restart the backup key loop if there is an active trusted backup.\n     * Doesn't try to check the backup server side. To be called when a new\n     * megolm key is known locally.\n     */\n    public async maybeUploadKey(): Promise<void> {\n        if (this.activeBackupVersion != null) {\n            this.backupKeysLoop();\n        }\n    }\n\n    private async disableKeyBackup(): Promise<void> {\n        await this.olmMachine.disableBackup();\n        this.activeBackupVersion = null;\n        this.emit(CryptoEvent.KeyBackupStatus, false);\n    }\n\n    private async backupKeysLoop(maxDelay = 10000): Promise<void> {\n        if (this.backupKeysLoopRunning) {\n            this.logger.debug(`Backup loop already running`);\n            return;\n        }\n        this.backupKeysLoopRunning = true;\n\n        this.logger.debug(`Backup: Starting keys upload loop for backup version:${this.activeBackupVersion}.`);\n\n        // wait between 0 and `maxDelay` seconds, to avoid backup\n        // requests from different clients hitting the server all at\n        // the same time when a new key is sent\n        const delay = Math.random() * maxDelay;\n        await sleep(delay);\n\n        try {\n            // number of consecutive network failures for exponential backoff\n            let numFailures = 0;\n            // The number of keys left to back up. (Populated lazily: see more comments below.)\n            let remainingToUploadCount: number | null = null;\n            // To avoid computing the key when only a few keys were added (after a sync for example),\n            // we compute the count only when at least two iterations are needed.\n            let isFirstIteration = true;\n\n            while (!this.stopped) {\n                // Get a batch of room keys to upload\n                let request: RustSdkCryptoJs.KeysBackupRequest | undefined = undefined;\n                try {\n                    request = await logDuration(\n                        this.logger,\n                        \"BackupRoomKeys: Get keys to backup from rust crypto-sdk\",\n                        async () => {\n                            return await this.olmMachine.backupRoomKeys();\n                        },\n                    );\n                } catch (err) {\n                    this.logger.error(\"Backup: Failed to get keys to backup from rust crypto-sdk\", err);\n                }\n\n                if (!request || this.stopped || !this.activeBackupVersion) {\n                    this.logger.debug(`Backup: Ending loop for version ${this.activeBackupVersion}.`);\n                    if (!request) {\n                        // nothing more to upload\n                        this.emit(CryptoEvent.KeyBackupSessionsRemaining, 0);\n                    }\n                    return;\n                }\n\n                try {\n                    await this.outgoingRequestProcessor.makeOutgoingRequest(request);\n                    numFailures = 0;\n                    if (this.stopped) break;\n\n                    // Key count performance (`olmMachine.roomKeyCounts()`) can be pretty bad on some configurations.\n                    // In particular, we detected on some M1 macs that when the object store reaches a threshold, the count\n                    // performance stops growing in O(n) and suddenly becomes very slow (40s, 60s or more).\n                    // For reference, the performance drop occurs around 300-400k keys on the platforms where this issue is observed.\n                    // Even on other configurations, the count can take several seconds.\n                    // This will block other operations on the database, like sending messages.\n                    //\n                    // This is a workaround to avoid calling `olmMachine.roomKeyCounts()` too often, and only when necessary.\n                    // We don't call it on the first loop because there could be only a few keys to upload, and we don't want to wait for the count.\n                    if (!isFirstIteration && remainingToUploadCount === null) {\n                        try {\n                            const keyCount = await this.olmMachine.roomKeyCounts();\n                            remainingToUploadCount = keyCount.total - keyCount.backedUp;\n                        } catch (err) {\n                            this.logger.error(\"Backup: Failed to get key counts from rust crypto-sdk\", err);\n                        }\n                    }\n\n                    if (remainingToUploadCount !== null) {\n                        this.emit(CryptoEvent.KeyBackupSessionsRemaining, remainingToUploadCount);\n                        const keysCountInBatch = this.keysCountInBatch(request);\n                        // `OlmMachine.roomKeyCounts` is called only once for the current backupKeysLoop. But new\n                        // keys could be added during the current loop (after a sync for example).\n                        // So the count can get out of sync with the real number of remaining keys to upload.\n                        // Depending on the number of new keys imported and the time to complete the loop,\n                        // this could result in multiple events being emitted with a remaining key count of 0.\n                        remainingToUploadCount = Math.max(remainingToUploadCount - keysCountInBatch, 0);\n                    }\n                } catch (err) {\n                    numFailures++;\n                    this.logger.error(\"Backup: Error processing backup request for rust crypto-sdk\", err);\n                    if (err instanceof MatrixError) {\n                        const errCode = err.data.errcode;\n                        if (errCode == \"M_NOT_FOUND\" || errCode == \"M_WRONG_ROOM_KEYS_VERSION\") {\n                            this.logger.debug(`Backup: Failed to upload keys to current vesion: ${errCode}.`);\n                            try {\n                                await this.disableKeyBackup();\n                            } catch (error) {\n                                this.logger.error(\"Backup: An error occurred while disabling key backup:\", error);\n                            }\n                            this.emit(CryptoEvent.KeyBackupFailed, err.data.errcode!);\n                            // There was an active backup and we are out of sync with the server\n                            // force a check server side\n                            this.backupKeysLoopRunning = false;\n                            this.checkKeyBackupAndEnable(true);\n                            return;\n                        } else if (err.isRateLimitError()) {\n                            // wait for that and then continue?\n                            try {\n                                const waitTime = err.getRetryAfterMs();\n                                if (waitTime && waitTime > 0) {\n                                    await sleep(waitTime);\n                                    continue;\n                                }\n                            } catch (error) {\n                                this.logger.warn(\n                                    \"Backup: An error occurred while retrieving a rate-limit retry delay\",\n                                    error,\n                                );\n                            } // else go to the normal backoff\n                        }\n                    }\n\n                    // Some other errors (mx, network, or CORS or invalid urls?) anyhow backoff\n                    // exponential backoff if we have failures\n                    await sleep(1000 * Math.pow(2, Math.min(numFailures - 1, 4)));\n                }\n                isFirstIteration = false;\n            }\n        } finally {\n            this.backupKeysLoopRunning = false;\n        }\n    }\n\n    /**\n     * Utility method to count the number of keys in a backup request, in order to update the remaining keys count.\n     * This should be the chunk size of the backup request for all requests but the last, but we don't have access to it\n     * (it's static in the Rust SDK).\n     * @param batch - The backup request to count the keys from.\n     *\n     * @returns The number of keys in the backup request.\n     */\n    private keysCountInBatch(batch: RustSdkCryptoJs.KeysBackupRequest): number {\n        const parsedBody: KeyBackup = JSON.parse(batch.body);\n        return countKeysInBackup(parsedBody);\n    }\n\n    /**\n     * Get information about a key backup from the server\n     * - If version is provided, get information about that backup version.\n     * - If no version is provided, get information about the latest backup.\n     *\n     * @param version - The version of the backup to get information about.\n     * @returns Information object from API or null if there is no active backup.\n     */\n    public async requestKeyBackupVersion(version?: string): Promise<KeyBackupInfo | null> {\n        return await requestKeyBackupVersion(this.http, version);\n    }\n\n    /**\n     * Creates a new key backup by generating a new random private key.\n     *\n     * If there is an existing backup server side it will be deleted and replaced\n     * by the new one.\n     *\n     * @param signObject - Method that should sign the backup with existing device and\n     * existing identity.\n     * @returns a KeyBackupCreationInfo - All information related to the backup.\n     */\n    public async setupKeyBackup(signObject: (authData: AuthData) => Promise<void>): Promise<KeyBackupCreationInfo> {\n        // Clean up any existing backup\n        await this.deleteAllKeyBackupVersions();\n\n        const randomKey = RustSdkCryptoJs.BackupDecryptionKey.createRandomKey();\n        const pubKey = randomKey.megolmV1PublicKey;\n\n        const authData = { public_key: pubKey.publicKeyBase64 };\n\n        await signObject(authData);\n\n        const res = await this.http.authedRequest<{ version: string }>(\n            Method.Post,\n            \"/room_keys/version\",\n            undefined,\n            {\n                algorithm: pubKey.algorithm,\n                auth_data: authData,\n            },\n            {\n                prefix: ClientPrefix.V3,\n            },\n        );\n\n        await this.saveBackupDecryptionKey(randomKey, res.version);\n\n        return {\n            version: res.version,\n            algorithm: pubKey.algorithm,\n            authData: authData,\n            decryptionKey: randomKey,\n        };\n    }\n\n    /**\n     * Deletes all key backups.\n     *\n     * Will call the API to delete active backup until there is no more present.\n     */\n    public async deleteAllKeyBackupVersions(): Promise<void> {\n        // there could be several backup versions. Delete all to be safe.\n        let current = (await this.requestKeyBackupVersion())?.version ?? null;\n        while (current != null) {\n            await this.deleteKeyBackupVersion(current);\n            current = (await this.requestKeyBackupVersion())?.version ?? null;\n        }\n\n        // XXX: Should this also update Secret Storage and delete any existing keys?\n    }\n\n    /**\n     * Deletes the given key backup.\n     *\n     * @param version - The backup version to delete.\n     */\n    public async deleteKeyBackupVersion(version: string): Promise<void> {\n        this.logger.debug(`deleteKeyBackupVersion v:${version}`);\n        const path = encodeUri(\"/room_keys/version/$version\", { $version: version });\n        await this.http.authedRequest<void>(Method.Delete, path, undefined, undefined, {\n            prefix: ClientPrefix.V3,\n        });\n        // If the backup we are deleting is the active one, we need to disable the key backup and to have the local properties reset\n        if (this.activeBackupVersion === version) {\n            this.serverBackupInfo = null;\n            await this.disableKeyBackup();\n        }\n    }\n\n    /**\n     * Creates a new backup decryptor for the given private key.\n     * @param decryptionKey - The private key to use for decryption.\n     */\n    public createBackupDecryptor(decryptionKey: RustSdkCryptoJs.BackupDecryptionKey): BackupDecryptor {\n        return new RustBackupDecryptor(this.logger, decryptionKey);\n    }\n\n    /**\n     * Restore a key backup.\n     *\n     * @param backupVersion - The version of the backup to restore.\n     * @param backupDecryptor - The backup decryptor to use to decrypt the keys.\n     * @param opts - Options for the restore.\n     * @returns The total number of keys and the total imported.\n     */\n    public async restoreKeyBackup(\n        backupVersion: string,\n        backupDecryptor: BackupDecryptor,\n        opts?: KeyBackupRestoreOpts,\n    ): Promise<KeyBackupRestoreResult> {\n        const keyBackup = await this.downloadKeyBackup(backupVersion);\n\n        return this.importKeyBackup(keyBackup, backupVersion, backupDecryptor, opts);\n    }\n\n    /**\n     * Call `/room_keys/keys` to download the key backup (room keys) for the given backup version.\n     * https://spec.matrix.org/v1.12/client-server-api/#get_matrixclientv3room_keyskeys\n     *\n     * @param backupVersion\n     * @returns The key backup response.\n     */\n    private downloadKeyBackup(backupVersion: string): Promise<KeyBackup> {\n        return this.http.authedRequest<KeyBackup>(\n            Method.Get,\n            \"/room_keys/keys\",\n            { version: backupVersion },\n            undefined,\n            {\n                prefix: ClientPrefix.V3,\n            },\n        );\n    }\n\n    /**\n     * Import the room keys from a `/room_keys/keys` call.\n     * Calls `opts.progressCallback` with the progress of the import.\n     *\n     * @param keyBackup - The response from the server containing the keys to import.\n     * @param backupVersion - The version of the backup info.\n     * @param backupDecryptor - The backup decryptor to use to decrypt the keys.\n     * @param opts - Options for the import.\n     *\n     * @returns The total number of keys and the total imported.\n     *\n     * @private\n     */\n    private async importKeyBackup(\n        keyBackup: KeyBackup,\n        backupVersion: string,\n        backupDecryptor: BackupDecryptor,\n        opts?: KeyBackupRestoreOpts,\n    ): Promise<KeyBackupRestoreResult> {\n        // We have a full backup here, it can get quite big, so we need to decrypt and import it in chunks.\n\n        const CHUNK_SIZE = 200;\n        // Get the total count as a first pass\n        const totalKeyCount = countKeysInBackup(keyBackup);\n        let totalImported = 0;\n        let totalFailures = 0;\n\n        opts?.progressCallback?.({\n            total: totalKeyCount,\n            successes: totalImported,\n            stage: ImportRoomKeyStage.LoadKeys,\n            failures: totalFailures,\n        });\n\n        /**\n         * This method is called when we have enough chunks to decrypt.\n         * It will decrypt the chunks and try to import the room keys.\n         * @param roomChunks\n         */\n        const handleChunkCallback = async (roomChunks: Map<string, KeyBackupRoomSessions>): Promise<void> => {\n            const currentChunk: IMegolmSessionData[] = [];\n            for (const roomId of roomChunks.keys()) {\n                // Decrypt the sessions for the given room\n                const decryptedSessions = await backupDecryptor.decryptSessions(roomChunks.get(roomId)!);\n                // Add the decrypted sessions to the current chunk\n                decryptedSessions.forEach((session) => {\n                    // We set the room_id for each session\n                    session.room_id = roomId;\n                    currentChunk.push(session);\n                });\n            }\n\n            // We have a chunk of decrypted keys: import them\n            try {\n                await this.importBackedUpRoomKeys(currentChunk, backupVersion);\n                totalImported += currentChunk.length;\n            } catch (e) {\n                totalFailures += currentChunk.length;\n                // We failed to import some keys, but we should still try to import the rest?\n                // Log the error and continue\n                this.logger.error(\"Error importing keys from backup\", e);\n            }\n\n            opts?.progressCallback?.({\n                total: totalKeyCount,\n                successes: totalImported,\n                stage: ImportRoomKeyStage.LoadKeys,\n                failures: totalFailures,\n            });\n        };\n\n        let groupChunkCount = 0;\n        let chunkGroupByRoom: Map<string, KeyBackupRoomSessions> = new Map();\n\n        // Iterate over the rooms and sessions to group them in chunks\n        // And we call the handleChunkCallback when we have enough chunks to decrypt\n        for (const [roomId, roomData] of Object.entries(keyBackup.rooms)) {\n            // If there are no sessions for the room, skip it\n            if (!roomData.sessions) continue;\n\n            // Initialize a new chunk group for the current room\n            chunkGroupByRoom.set(roomId, {});\n\n            for (const [sessionId, session] of Object.entries(roomData.sessions)) {\n                // We set previously the chunk group for the current room, so we can safely get it\n                const sessionsForRoom = chunkGroupByRoom.get(roomId)!;\n                sessionsForRoom[sessionId] = session;\n                groupChunkCount += 1;\n                // If we have enough chunks to decrypt, call the block callback\n                if (groupChunkCount >= CHUNK_SIZE) {\n                    // We have enough chunks to decrypt\n                    await handleChunkCallback(chunkGroupByRoom);\n                    // Reset the chunk group\n                    chunkGroupByRoom = new Map();\n                    // There might be remaining keys for that room, so add back an entry for the current room.\n                    chunkGroupByRoom.set(roomId, {});\n                    groupChunkCount = 0;\n                }\n            }\n        }\n\n        // Handle remaining chunk if needed\n        if (groupChunkCount > 0) {\n            await handleChunkCallback(chunkGroupByRoom);\n        }\n\n        return { total: totalKeyCount, imported: totalImported };\n    }\n\n    /**\n     * Checks if the provided backup info matches the given private key.\n     *\n     * @param info - The backup info to check.\n     * @param backupDecryptionKey - The `BackupDecryptionKey` private key to check against.\n     * @returns `true` if the private key can decrypt the backup, `false` otherwise.\n     */\n    private backupInfoMatchesBackupDecryptionKey(\n        info: KeyBackupInfo,\n        backupDecryptionKey: RustSdkCryptoJs.BackupDecryptionKey,\n    ): boolean {\n        if (info.algorithm !== \"m.megolm_backup.v1.curve25519-aes-sha2\") {\n            this.logger.warn(\"backupMatchesPrivateKey: Unsupported backup algorithm\", info.algorithm);\n            return false;\n        }\n\n        return (\n            (info.auth_data as Curve25519AuthData)?.public_key === backupDecryptionKey.megolmV1PublicKey.publicKeyBase64\n        );\n    }\n}\n/**\n * Implementation of {@link BackupDecryptor} for the rust crypto backend.\n */\nexport class RustBackupDecryptor implements BackupDecryptor {\n    private decryptionKey: RustSdkCryptoJs.BackupDecryptionKey;\n    public sourceTrusted: boolean;\n\n    public constructor(\n        private readonly logger: Logger,\n        decryptionKey: RustSdkCryptoJs.BackupDecryptionKey,\n    ) {\n        this.decryptionKey = decryptionKey;\n        this.sourceTrusted = false;\n    }\n\n    /**\n     * Implements {@link BackupDecryptor#decryptSessions}\n     */\n    public async decryptSessions(\n        ciphertexts: Record<string, KeyBackupSession<Curve25519SessionData | AESEncryptedSecretStoragePayload>>,\n    ): Promise<IMegolmSessionData[]> {\n        const keys: IMegolmSessionData[] = [];\n        for (const [sessionId, sessionData] of Object.entries(ciphertexts)) {\n            try {\n                const decrypted = JSON.parse(\n                    this.decryptionKey.decryptV1(\n                        sessionData.session_data.ephemeral,\n                        sessionData.session_data.mac,\n                        sessionData.session_data.ciphertext,\n                    ),\n                );\n                decrypted.session_id = sessionId;\n                keys.push(decrypted);\n            } catch (e) {\n                this.logger.debug(\"Failed to decrypt megolm session from backup\", e, sessionData);\n            }\n        }\n        return keys;\n    }\n\n    /**\n     * Implements {@link BackupDecryptor#free}\n     */\n    public free(): void {\n        this.decryptionKey.free();\n    }\n}\n\n/**\n * Fetch a key backup info from the server.\n *\n * If `version` is provided, calls `GET /room_keys/version/$version` and gets the backup info for that version.\n * See https://spec.matrix.org/v1.12/client-server-api/#get_matrixclientv3room_keysversionversion.\n *\n * If not, calls `GET /room_keys/version` and gets the latest backup info.\n * See https://spec.matrix.org/v1.12/client-server-api/#get_matrixclientv3room_keysversion\n *\n * @param http\n * @param version - the specific version of the backup info to fetch\n * @returns The key backup info or null if there is no backup.\n */\nexport async function requestKeyBackupVersion(\n    http: MatrixHttpApi<IHttpOpts & { onlyData: true }>,\n    version?: string,\n): Promise<KeyBackupInfo | null> {\n    try {\n        const path = version ? encodeUri(\"/room_keys/version/$version\", { $version: version }) : \"/room_keys/version\";\n        return await http.authedRequest<KeyBackupInfo>(Method.Get, path, undefined, undefined, {\n            prefix: ClientPrefix.V3,\n        });\n    } catch (e) {\n        if ((<MatrixError>e).errcode === \"M_NOT_FOUND\") {\n            return null;\n        } else {\n            throw e;\n        }\n    }\n}\n\n/**\n * Checks if the provided decryption key matches the public key of the key backup info.\n *\n * @param decryptionKey - The decryption key to check.\n * @param keyBackupInfo - The key backup info to check against.\n * @returns `true` if the decryption key matches the key backup info, `false` otherwise.\n */\nexport function decryptionKeyMatchesKeyBackupInfo(\n    decryptionKey: RustSdkCryptoJs.BackupDecryptionKey,\n    keyBackupInfo: KeyBackupInfo,\n): boolean {\n    const authData = <Curve25519AuthData>keyBackupInfo.auth_data;\n    return authData.public_key === decryptionKey.megolmV1PublicKey.publicKeyBase64;\n}\n\n/**\n * Counts the total number of keys present in a key backup.\n * @param keyBackup - The key backup to count the keys from.\n * @returns The total number of keys in the backup.\n */\nfunction countKeysInBackup(keyBackup: KeyBackup): number {\n    let count = 0;\n    for (const { sessions } of Object.values(keyBackup.rooms)) {\n        count += Object.keys(sessions).length;\n    }\n    return count;\n}\n\nexport type RustBackupCryptoEvents =\n    | CryptoEvent.KeyBackupStatus\n    | CryptoEvent.KeyBackupSessionsRemaining\n    | CryptoEvent.KeyBackupFailed\n    | CryptoEvent.KeyBackupDecryptionKeyCached;\n\nexport type RustBackupCryptoEventMap = {\n    [CryptoEvent.KeyBackupStatus]: (enabled: boolean) => void;\n    [CryptoEvent.KeyBackupSessionsRemaining]: (remaining: number) => void;\n    [CryptoEvent.KeyBackupFailed]: (errCode: string) => void;\n    [CryptoEvent.KeyBackupDecryptionKeyCached]: (version: string) => void;\n};\n\n/**\n * Response from GET `/room_keys/keys` endpoint.\n * See https://spec.matrix.org/latest/client-server-api/#get_matrixclientv3room_keyskeys\n */\nexport interface KeyBackup {\n    rooms: Record<string, { sessions: KeyBackupRoomSessions }>;\n}\n"],"mappings":"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","ignoreList":[]}