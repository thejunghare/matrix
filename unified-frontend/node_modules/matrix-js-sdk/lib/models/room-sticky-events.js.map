{"version":3,"file":"room-sticky-events.js","names":["logger","loggerInstance","TypedEventEmitter","getChild","RoomStickyEventsEvent","assertIsUserId","value","Error","startsWith","RoomStickyEventsStore","constructor","arguments","_defineProperty","Map","Set","Number","MAX_SAFE_INTEGER","now","Date","removedEvents","nextStickyEventExpiryTs","eventType","innerEvents","stickyEventsMap","entries","_this$stickyEventsMap","innerMapKey","currentEvent","previousEvents","unstableStickyExpiresAt","debug","getId","push","get","delete","set","filter","e","Math","min","size","event","unkeyedStickyEvents","length","emit","Update","scheduleStickyTimer","sortStickyEvent","eventA","eventB","_eventB$getId","_eventA$getId","getTs","stickyMapKey","stickyKey","sender","concat","getStickyEvents","innerMap","values","events","getKeyedStickyEvent","type","_this$stickyEventsMap2","getUnkeyedStickyEvent","ev","getType","getSender","addStickyEvent","_this$stickyEventsMap3","_this$stickyEventsMap4","_this$stickyEventsMap5","getContent","msc4354_sticky_key","undefined","info","added","stickyEvent","add","currentEventSet","sort","has","prevEvent","addStickyEvents","updated","result","current","previous","ex","warn","stickyEventTimer","clearTimeout","setTimeout","cleanExpiredStickyEvents","handleRedaction","redactedEvent","redactEventId","isRedacted","_innerMap$get","_this$stickyEventsMap6","mapKey","newEvents","clear"],"sources":["../../src/models/room-sticky-events.ts"],"sourcesContent":["import { logger as loggerInstance } from \"../logger.ts\";\nimport { type MatrixEvent } from \"./event.ts\";\nimport { TypedEventEmitter } from \"./typed-event-emitter.ts\";\n\nconst logger = loggerInstance.getChild(\"RoomStickyEvents\");\n\nexport enum RoomStickyEventsEvent {\n    Update = \"RoomStickyEvents.Update\",\n}\n\nexport type StickyMatrixEvent = MatrixEvent & { unstableStickyExpiresAt: number };\n\nexport type RoomStickyEventsMap = {\n    /**\n     * Fires when any sticky event changes happen in a room.\n     * @param added Any new sticky events with no predecessor events (matching sender, type, and sticky_key)\n     * @param updated Any sticky events that supersede an existing event (matching sender, type, and sticky_key)\n     * @param removed The events that were removed from the map due to expiry.\n     */\n    [RoomStickyEventsEvent.Update]: (\n        added: StickyMatrixEvent[],\n        updated: { current: StickyMatrixEvent; previous: StickyMatrixEvent }[],\n        removed: StickyMatrixEvent[],\n    ) => void;\n};\n\ntype UserId = `@${string}`;\n\nfunction assertIsUserId(value: unknown): asserts value is UserId {\n    if (typeof value !== \"string\") throw new Error(\"Not a string\");\n    if (!value.startsWith(\"@\")) throw new Error(\"Not a userId\");\n}\n\n/**\n * Tracks sticky events on behalf of one room, and fires an event\n * whenever a sticky event is updated or replaced.\n */\nexport class RoomStickyEventsStore extends TypedEventEmitter<RoomStickyEventsEvent, RoomStickyEventsMap> {\n    /**\n     * Sticky event map is a nested map of:\n     *  eventType -> `content.sticky_key sender` -> StickyMatrixEvent[]\n     *\n     * The events are ordered in latest to earliest expiry, so that the first event\n     * in the array will always be the \"current\" one.\n     */\n    private readonly stickyEventsMap = new Map<string, Map<string, StickyMatrixEvent[]>>();\n    /**\n     * These are sticky events that have no sticky key and therefore exist outside the tuple\n     * system above. They are just held in this Set until they expire.\n     */\n    private readonly unkeyedStickyEvents = new Set<StickyMatrixEvent>();\n\n    private stickyEventTimer?: ReturnType<typeof setTimeout>;\n    private nextStickyEventExpiryTs: number = Number.MAX_SAFE_INTEGER;\n\n    /**\n     * Sort two sticky events by order of expiry. This assumes the sticky events have the same\n     * `type`, `sticky_key` and `sender`.\n     * @returns A positive value if event A will expire sooner, or a negative value if event B will expire sooner.\n     */\n    private static sortStickyEvent(eventA: StickyMatrixEvent, eventB: StickyMatrixEvent): number {\n        // Sticky events with the same key have to use the same expiration duration.\n        // Hence, comparing via `origin_server_ts` yields the exact same result as comparing their expiration time.\n        if (eventB.getTs() !== eventA.getTs()) {\n            return eventB.getTs() - eventA.getTs();\n        }\n\n        if ((eventB.getId() ?? \"\") > (eventA.getId() ?? \"\")) {\n            return 1;\n        }\n\n        // This should fail as we've got corruption in our sticky array.\n        throw Error(\"Comparing two sticky events with the same event ID is not allowed.\");\n    }\n\n    /**\n     * Generate the correct key for an event to be found in the inner maps of `stickyEventsMap`.\n     * @param stickyKey The sticky key of an event.\n     * @param sender The sender of the event.\n     */\n    private static stickyMapKey(stickyKey: string, sender: UserId): string {\n        return `${stickyKey}${sender}`;\n    }\n\n    /**\n     * Get all sticky events that are currently active.\n     * @returns An iterable set of events.\n     */\n    public *getStickyEvents(): Iterable<StickyMatrixEvent> {\n        yield* this.unkeyedStickyEvents;\n        for (const innerMap of this.stickyEventsMap.values()) {\n            // Inner map contains a map of sender+stickykeys => all sticky events\n            for (const events of innerMap.values()) {\n                // The first sticky event is the \"current\" one in the sticky map.\n                yield events[0];\n            }\n        }\n    }\n\n    /**\n     * Get an active sticky event that match the given `type`, `sender`, and `stickyKey`\n     * @param type The event `type`.\n     * @param sender The sender of the sticky event.\n     * @param stickyKey The sticky key used by the event.\n     * @returns A matching active sticky event, or undefined.\n     */\n    public getKeyedStickyEvent(sender: string, type: string, stickyKey: string): StickyMatrixEvent | undefined {\n        assertIsUserId(sender);\n        return this.stickyEventsMap.get(type)?.get(RoomStickyEventsStore.stickyMapKey(stickyKey, sender))?.[0];\n    }\n\n    /**\n     * Get active sticky events without a sticky key that match the given `type` and `sender`.\n     * @param type The event `type`.\n     * @param sender The sender of the sticky event.\n     * @returns An array of matching sticky events.\n     */\n    public getUnkeyedStickyEvent(sender: string, type: string): StickyMatrixEvent[] {\n        return [...this.unkeyedStickyEvents].filter((ev) => ev.getType() === type && ev.getSender() === sender);\n    }\n\n    /**\n     * Adds a sticky event into the local sticky event map.\n     *\n     * NOTE: This will not cause `RoomEvent.StickyEvents` to be emitted.\n     *\n     * @throws If the `event` does not contain valid sticky data.\n     * @param event The MatrixEvent that contains sticky data.\n     * @returns An object describing whether the event was added to the map,\n     *          and the previous event it may have replaced.\n     */\n    private addStickyEvent(event: MatrixEvent): { added: true; prevEvent?: StickyMatrixEvent } | { added: false } {\n        const stickyKey = event.getContent().msc4354_sticky_key;\n        if (typeof stickyKey !== \"string\" && stickyKey !== undefined) {\n            throw new Error(`${event.getId()} is missing msc4354_sticky_key`);\n        }\n\n        // With this we have the guarantee, that all events in stickyEventsMap are correctly formatted\n        if (event.unstableStickyExpiresAt === undefined) {\n            throw new Error(`${event.getId()} is missing msc4354_sticky.duration_ms`);\n        }\n        const sender = event.getSender();\n        const type = event.getType();\n        assertIsUserId(sender);\n        if (event.unstableStickyExpiresAt <= Date.now()) {\n            logger.info(\"ignored sticky event with older expiration time than current time\", stickyKey);\n            return { added: false };\n        }\n\n        // While we fully expect the server to always provide the correct value,\n        // this is just insurance to protect against attacks on our Map.\n        if (!sender.startsWith(\"@\")) {\n            throw new Error(\"Expected sender to start with @\");\n        }\n\n        const stickyEvent = event as StickyMatrixEvent;\n\n        if (stickyKey === undefined) {\n            this.unkeyedStickyEvents.add(stickyEvent);\n            // Recalculate the next expiry time.\n            this.nextStickyEventExpiryTs = Math.min(event.unstableStickyExpiresAt, this.nextStickyEventExpiryTs);\n\n            this.scheduleStickyTimer();\n            return { added: true };\n        }\n\n        // Why this is safe:\n        // A type may contain anything but the *sender* is tightly\n        // constrained so that a key will always end with a @<user_id>\n        // E.g. Where a malicious event type might be \"rtc.member.event@foo:bar\" the key becomes:\n        // \"rtc.member.event.@foo:bar@bar:baz\"\n        const innerMapKey = RoomStickyEventsStore.stickyMapKey(stickyKey, sender);\n        const currentEventSet = [stickyEvent, ...(this.stickyEventsMap.get(type)?.get(innerMapKey) ?? [])].sort(\n            RoomStickyEventsStore.sortStickyEvent,\n        );\n        if (!this.stickyEventsMap.has(type)) {\n            this.stickyEventsMap.set(type, new Map());\n        }\n        this.stickyEventsMap.get(type)?.set(innerMapKey, currentEventSet);\n\n        // Recalculate the next expiry time.\n        this.nextStickyEventExpiryTs = Math.min(stickyEvent.unstableStickyExpiresAt, this.nextStickyEventExpiryTs);\n\n        this.scheduleStickyTimer();\n        return {\n            added: currentEventSet[0] === stickyEvent,\n            prevEvent: currentEventSet?.[1],\n        };\n    }\n\n    /**\n     * Add a series of sticky events, emitting `RoomEvent.StickyEvents` if any\n     * changes were made.\n     * @param events A set of new sticky events.\n     */\n    public addStickyEvents(events: MatrixEvent[]): void {\n        const added: StickyMatrixEvent[] = [];\n        const updated: { current: StickyMatrixEvent; previous: StickyMatrixEvent }[] = [];\n        for (const event of events) {\n            try {\n                const result = this.addStickyEvent(event);\n                if (result.added) {\n                    if (result.prevEvent) {\n                        // e is validated as a StickyMatrixEvent by virtue of `addStickyEvent` returning added: true.\n                        updated.push({ current: event as StickyMatrixEvent, previous: result.prevEvent });\n                    } else {\n                        added.push(event as StickyMatrixEvent);\n                    }\n                }\n            } catch (ex) {\n                logger.warn(\"ignored invalid sticky event\", ex);\n            }\n        }\n        if (added.length || updated.length) this.emit(RoomStickyEventsEvent.Update, added, updated, []);\n        this.scheduleStickyTimer();\n    }\n\n    /**\n     * Schedule the sticky event expiry timer. The timer will\n     * run immediately if an event has already expired.\n     */\n    private scheduleStickyTimer(): void {\n        if (this.stickyEventTimer) {\n            clearTimeout(this.stickyEventTimer);\n            this.stickyEventTimer = undefined;\n        }\n        if (this.nextStickyEventExpiryTs === Number.MAX_SAFE_INTEGER) {\n            // We have no events due to expire.\n            return;\n        } // otherwise, schedule in the future\n        this.stickyEventTimer = setTimeout(this.cleanExpiredStickyEvents, this.nextStickyEventExpiryTs - Date.now());\n    }\n\n    /**\n     * Clean out any expired sticky events.\n     */\n    private readonly cleanExpiredStickyEvents = (): void => {\n        const now = Date.now();\n        const removedEvents: StickyMatrixEvent[] = [];\n\n        // We will recalculate this as we check all events.\n        this.nextStickyEventExpiryTs = Number.MAX_SAFE_INTEGER;\n        for (const [eventType, innerEvents] of this.stickyEventsMap.entries()) {\n            for (const [innerMapKey, [currentEvent, ...previousEvents]] of innerEvents) {\n                // we only added items with `sticky` into this map so we can assert non-null here\n                if (now >= currentEvent.unstableStickyExpiresAt) {\n                    logger.debug(\"Expiring sticky event\", currentEvent.getId());\n                    removedEvents.push(currentEvent);\n                    this.stickyEventsMap.get(eventType)!.delete(innerMapKey);\n                } else {\n                    // Ensure we remove any previous events which have now expired, to avoid unbounded memory consumption.\n                    this.stickyEventsMap\n                        .get(eventType)!\n                        .set(innerMapKey, [\n                            currentEvent,\n                            ...previousEvents.filter((e) => e.unstableStickyExpiresAt <= now),\n                        ]);\n                    // If not removing the event, check to see if it's the next lowest expiry.\n                    this.nextStickyEventExpiryTs = Math.min(\n                        this.nextStickyEventExpiryTs,\n                        currentEvent.unstableStickyExpiresAt,\n                    );\n                }\n            }\n            // Clean up map after use.\n            if (this.stickyEventsMap.get(eventType)?.size === 0) {\n                this.stickyEventsMap.delete(eventType);\n            }\n        }\n        for (const event of this.unkeyedStickyEvents) {\n            if (now >= event.unstableStickyExpiresAt) {\n                logger.debug(\"Expiring sticky event\", event.getId());\n                this.unkeyedStickyEvents.delete(event);\n                removedEvents.push(event);\n            } else {\n                // If not removing the event, check to see if it's the next lowest expiry.\n                this.nextStickyEventExpiryTs = Math.min(this.nextStickyEventExpiryTs, event.unstableStickyExpiresAt);\n            }\n        }\n        if (removedEvents.length) {\n            this.emit(RoomStickyEventsEvent.Update, [], [], removedEvents);\n        }\n        // Finally, schedule the next run.\n        this.scheduleStickyTimer();\n    };\n\n    /**\n     * Handles incoming event redactions. Checks the sticky map\n     * for any active sticky events being redacted.\n     * @param redactedEvent The MatrixEvent OR event ID of the event being redacted. MAY not be a sticky event.\n     */\n    public handleRedaction(redactedEvent: MatrixEvent | string): void {\n        // Note, we do not adjust`nextStickyEventExpiryTs` here.\n        // If this event happens to be the most recent expiring event\n        // then we may do one extra iteration of cleanExpiredStickyEvents\n        // but this saves us having to iterate over all events here to calculate\n        // the next expiry time.\n\n        // Note, as soon as we find a positive match on an event in this function\n        // we can return. There is no need to continue iterating on a positive match\n        // as an event can only appear in one map.\n\n        // Handle unkeyedStickyEvents first since it's *quick*.\n        const redactEventId = typeof redactedEvent === \"string\" ? redactedEvent : redactedEvent.getId();\n        for (const event of this.unkeyedStickyEvents) {\n            if (event.getId() === redactEventId) {\n                this.unkeyedStickyEvents.delete(event);\n                this.emit(RoomStickyEventsEvent.Update, [], [], [event]);\n                return;\n            }\n        }\n\n        // Faster method of finding the event since we have the event cached.\n        if (typeof redactedEvent !== \"string\" && !redactedEvent.isRedacted()) {\n            const stickyKey = redactedEvent.getContent().msc4354_sticky_key;\n            if (typeof stickyKey !== \"string\" && stickyKey !== undefined) {\n                return; // Not a sticky event.\n            }\n            const eventType = redactedEvent.getType();\n            const sender = redactedEvent.getSender();\n            assertIsUserId(sender);\n            const innerMap = this.stickyEventsMap.get(eventType);\n            if (!innerMap) {\n                return;\n            }\n            const mapKey = RoomStickyEventsStore.stickyMapKey(stickyKey, sender);\n            const [currentEvent, ...previousEvents] = innerMap.get(mapKey) ?? [];\n            if (!currentEvent) {\n                // No event current in the map so ignore.\n                return;\n            }\n            logger.debug(`Redaction for ${redactEventId} under sticky key ${stickyKey}`);\n            // Revert to previous state, taking care to skip any other redacted events.\n            const newEvents = previousEvents.filter((e) => !e.isRedacted()).sort(RoomStickyEventsStore.sortStickyEvent);\n            this.stickyEventsMap.get(eventType)?.set(mapKey, newEvents);\n            if (newEvents.length) {\n                this.emit(\n                    RoomStickyEventsEvent.Update,\n                    [],\n                    [\n                        {\n                            // This looks confusing. This emits that the newer event\n                            // has been redacted and the previous event has taken it's place.\n                            previous: currentEvent,\n                            current: newEvents[0],\n                        },\n                    ],\n                    [],\n                );\n            } else {\n                // We did not find a previous event, so just expire.\n                innerMap.delete(mapKey);\n                if (innerMap.size === 0) {\n                    this.stickyEventsMap.delete(eventType);\n                }\n                this.emit(RoomStickyEventsEvent.Update, [], [], [currentEvent]);\n            }\n            return;\n        }\n\n        // We only know the event ID of the redacted event, so we need to\n        // traverse the map to find our event.\n        for (const innerMap of this.stickyEventsMap.values()) {\n            for (const [currentEvent] of innerMap.values()) {\n                if (currentEvent.getId() !== redactEventId) {\n                    continue;\n                }\n                // Found the event.\n                return this.handleRedaction(currentEvent);\n            }\n        }\n    }\n\n    /**\n     * Clear all events and stop the timer from firing.\n     */\n    public clear(): void {\n        this.stickyEventsMap.clear();\n        // Unschedule timer.\n        this.nextStickyEventExpiryTs = Number.MAX_SAFE_INTEGER;\n        this.scheduleStickyTimer();\n    }\n}\n"],"mappings":"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","ignoreList":[]}