import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/*
Copyright 2023 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/**
 * The mxID, deviceId and membership timestamp of a RTC session participant.
 */

/**
 * A type representing the information needed to decrypt video streams.
 */

/**
 * The information about the key used to encrypt video streams.
 */

/**
 * THe content of a to-device event that contains encryption keys.
 */

/**
 * @deprecated Use `RTCNotificationType` instead.
 */

/**
 * @deprecated Use `IRTCNotificationContent` instead.
 */

/**
 * Represents the intention of the call from the perspective of the sending user.
 * May be any string, although `"audio"` and `"video"` are commonly accepted values.
 */

/**
 * This will check if the content has all the expected fields to be a valid IRTCNotificationContent.
 * It will also cap the lifetime to 90000ms (1.5 min) if a higher value is provided.
 * @param content
 * @throws if the content is invalid
 * @returns a parsed IRTCNotificationContent
 */
export function parseCallNotificationContent(content) {
  if (content["m.mentions"] && typeof content["m.mentions"] !== "object") {
    throw new Error("malformed m.mentions");
  }
  if (typeof content["notification_type"] !== "string") {
    throw new Error("Missing or invalid notification_type");
  }
  if (typeof content["sender_ts"] !== "number") {
    throw new Error("Missing or invalid sender_ts");
  }
  if (typeof content["lifetime"] !== "number") {
    throw new Error("Missing or invalid lifetime");
  }
  if (content["relation"] && content["relation"]["rel_type"] !== "m.reference") {
    throw new Error("Invalid relation");
  }
  if (content["m.call.intent"] && typeof content["m.call.intent"] !== "string") {
    throw new Error("Invalid m.call.intent");
  }
  var cappedLifetime = content["lifetime"] >= 90000 ? 90000 : content["lifetime"];
  return _objectSpread(_objectSpread({}, content), {}, {
    lifetime: cappedLifetime
  });
}

/**
 * Interface for `org.matrix.msc4075.rtc.notification` events.
 * Don't cast event content to this directly. Use `parseCallNotificationContent` instead to validate the content first.
 */

/**
 * MSC4310 decline event content for `org.matrix.msc4310.rtc.decline`.
 * Sent as a standard m.reference relation to an `org.matrix.msc4075.rtc.notification` event.
 */

export var Status = /*#__PURE__*/function (Status) {
  Status["Disconnected"] = "Disconnected";
  Status["Connecting"] = "Connecting";
  Status["ConnectingFailed"] = "ConnectingFailed";
  Status["Connected"] = "Connected";
  Status["Reconnecting"] = "Reconnecting";
  Status["Disconnecting"] = "Disconnecting";
  Status["Stuck"] = "Stuck";
  Status["Unknown"] = "Unknown";
  return Status;
}({});

/**
 * A type collecting call encryption statistics for a session.
 */

export var isMyMembership = (m, userId, deviceId) => m.sender === userId && m.deviceId === deviceId;

/**
 *  A RTC transport is a JSON object that describes how to connect to a RTC member.
 */
//# sourceMappingURL=types.js.map