{"version":3,"file":"MembershipManagerActionScheduler.js","names":["logger","rootLogger","sleep","MembershipActionType","ActionScheduler","constructor","membershipLoopHandler","parentLogger","_defineProperty","update","error","getChild","actions","_actions","startWithJoin","_this","_asyncToGenerator","running","ts","Date","now","type","SendDelayedEvent","_loop","sort","a","b","nextAction","wakeupUpdate","undefined","wakeupPromise","Promise","resolve","wakeup","race","handlerResult","debug","concat","e","Error","splice","actionUpdate","replace","push","insert","length","initiateJoin","_this$wakeup","call","initiateLeave","_this$wakeup2","SendScheduledDelayedLeaveEvent"],"sources":["../../src/matrixrtc/MembershipManagerActionScheduler.ts"],"sourcesContent":["import { type Logger, logger as rootLogger } from \"../logger.ts\";\nimport { type EmptyObject } from \"../matrix.ts\";\nimport { sleep } from \"../utils.ts\";\nimport { MembershipActionType } from \"./MembershipManager.ts\";\n\n/** @internal */\nexport interface Action {\n    /**\n     * When this action should be executed\n     */\n    ts: number;\n    /**\n     * The state of the different loops\n     * can also be thought of as the type of the action\n     */\n    type: MembershipActionType;\n}\n\n/** @internal */\nexport type ActionUpdate =\n    | {\n          /** Replace all existing scheduled actions with this new array */\n          replace: Action[];\n      }\n    | {\n          /** Add these actions to the existing scheduled actions */\n          insert: Action[];\n      }\n    | EmptyObject;\n\n/**\n * This scheduler tracks the state of the current membership participation\n * and runs one central timer that wakes up a handler callback with the correct action + state\n * whenever necessary.\n *\n * It can also be awakened whenever a new action is added which is\n * earlier then the current \"next awake\".\n * @internal\n */\nexport class ActionScheduler {\n    private logger: Logger;\n    /**\n     * This is tracking the state of the scheduler loop.\n     * Only used to prevent starting the loop twice.\n     */\n    public running = false;\n\n    public constructor(\n        /** This is the callback called for each scheduled action (`this.addAction()`) */\n        private membershipLoopHandler: (type: MembershipActionType) => Promise<ActionUpdate>,\n        parentLogger?: Logger,\n    ) {\n        this.logger = (parentLogger ?? rootLogger).getChild(`[NewMembershipActionScheduler]`);\n    }\n\n    // function for the wakeup mechanism (in case we add an action externally and need to leave the current sleep)\n    private wakeup: (update: ActionUpdate) => void = (update: ActionUpdate): void => {\n        this.logger.error(\"Cannot call wakeup before calling `startWithJoin()`\");\n    };\n    private _actions: Action[] = [];\n    public get actions(): Action[] {\n        return this._actions;\n    }\n\n    /**\n     * This starts the main loop of the membership manager that handles event sending, delayed event sending and delayed event restarting.\n     * @param initialActions The initial actions the manager will start with. It should be enough to pass: DelayedLeaveActionType.Initial\n     * @returns Promise that resolves once all actions have run and no more are scheduled.\n     * @throws This throws an error if one of the actions throws.\n     * In most other error cases the manager will try to handle any server errors by itself.\n     */\n    public async startWithJoin(): Promise<void> {\n        if (this.running) {\n            this.logger.error(\"Cannot call startWithJoin() on NewMembershipActionScheduler while already running\");\n            return;\n        }\n        this.running = true;\n        this._actions = [{ ts: Date.now(), type: MembershipActionType.SendDelayedEvent }];\n        try {\n            while (this._actions.length > 0) {\n                // Sort so next (smallest ts) action is at the beginning\n                this._actions.sort((a, b) => a.ts - b.ts);\n                const nextAction = this._actions[0];\n                let wakeupUpdate: ActionUpdate | undefined = undefined;\n\n                // while we await for the next action, wakeup has to resolve the wakeupPromise\n                const wakeupPromise = new Promise<void>((resolve) => {\n                    this.wakeup = (update: ActionUpdate): void => {\n                        wakeupUpdate = update;\n                        resolve();\n                    };\n                });\n                if (nextAction.ts > Date.now()) await Promise.race([wakeupPromise, sleep(nextAction.ts - Date.now())]);\n\n                let handlerResult: ActionUpdate = {};\n                if (!wakeupUpdate) {\n                    this.logger.debug(\n                        `Current MembershipManager processing: ${nextAction.type}\\nQueue:`,\n                        this._actions,\n                        `\\nDate.now: \"${Date.now()}`,\n                    );\n                    try {\n                        // `this.wakeup` can also be called and sets the `wakeupUpdate` object while we are in the handler.\n                        handlerResult = await this.membershipLoopHandler(nextAction.type as MembershipActionType);\n                    } catch (e) {\n                        throw Error(`The MembershipManager shut down because of the end condition: ${e}`);\n                    }\n                }\n                // remove the processed action only after we are done processing\n                this._actions.splice(0, 1);\n                // The wakeupUpdate always wins since that is a direct external update.\n                const actionUpdate = wakeupUpdate ?? handlerResult;\n\n                if (\"replace\" in actionUpdate) {\n                    this._actions = actionUpdate.replace;\n                } else if (\"insert\" in actionUpdate) {\n                    this._actions.push(...actionUpdate.insert);\n                }\n            }\n        } finally {\n            // Set the rtc session running state since we cannot recover from here and the consumer user of the\n            // MatrixRTCSession class needs to manually rejoin.\n            this.running = false;\n        }\n\n        this.logger.debug(\"Leave MembershipManager ActionScheduler loop (no more actions)\");\n    }\n\n    public initiateJoin(): void {\n        this.wakeup?.({ replace: [{ ts: Date.now(), type: MembershipActionType.SendDelayedEvent }] });\n    }\n    public initiateLeave(): void {\n        this.wakeup?.({ replace: [{ ts: Date.now(), type: MembershipActionType.SendScheduledDelayedLeaveEvent }] });\n    }\n}\n"],"mappings":"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","ignoreList":[]}