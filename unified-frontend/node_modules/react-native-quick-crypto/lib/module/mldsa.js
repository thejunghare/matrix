"use strict";

import { NitroModules } from 'react-native-nitro-modules';
import { CryptoKey, KeyObject } from './keys';
import { hasAnyNotIn, lazyDOMException, getUsagesUnion, KFormatType, KeyEncoding } from './utils';
export class MlDsa {
  constructor(variant) {
    this.variant = variant;
    this.native = NitroModules.createHybridObject('MlDsaKeyPair');
    this.native.setVariant(variant);
  }
  async generateKeyPair() {
    await this.native.generateKeyPair(KFormatType.DER, KeyEncoding.SPKI, KFormatType.DER, KeyEncoding.PKCS8);
  }
  generateKeyPairSync() {
    this.native.generateKeyPairSync(KFormatType.DER, KeyEncoding.SPKI, KFormatType.DER, KeyEncoding.PKCS8);
  }
  getPublicKey() {
    return this.native.getPublicKey();
  }
  getPrivateKey() {
    return this.native.getPrivateKey();
  }
  async sign(message) {
    return this.native.sign(message);
  }
  signSync(message) {
    return this.native.signSync(message);
  }
  async verify(signature, message) {
    return this.native.verify(signature, message);
  }
  verifySync(signature, message) {
    return this.native.verifySync(signature, message);
  }
}
export async function mldsa_generateKeyPairWebCrypto(variant, extractable, keyUsages) {
  if (hasAnyNotIn(keyUsages, ['sign', 'verify'])) {
    throw lazyDOMException(`Unsupported key usage for ${variant}`, 'SyntaxError');
  }
  const publicUsages = getUsagesUnion(keyUsages, 'verify');
  const privateUsages = getUsagesUnion(keyUsages, 'sign');
  if (privateUsages.length === 0) {
    throw lazyDOMException('Usages cannot be empty', 'SyntaxError');
  }
  const mldsa = new MlDsa(variant);
  await mldsa.generateKeyPair();
  const publicKeyData = mldsa.getPublicKey();
  const privateKeyData = mldsa.getPrivateKey();
  const pub = KeyObject.createKeyObject('public', publicKeyData, KFormatType.DER, KeyEncoding.SPKI);
  const publicKey = new CryptoKey(pub, {
    name: variant
  }, publicUsages, true);
  const priv = KeyObject.createKeyObject('private', privateKeyData, KFormatType.DER, KeyEncoding.PKCS8);
  const privateKey = new CryptoKey(priv, {
    name: variant
  }, privateUsages, extractable);
  return {
    publicKey,
    privateKey
  };
}
//# sourceMappingURL=mldsa.js.map