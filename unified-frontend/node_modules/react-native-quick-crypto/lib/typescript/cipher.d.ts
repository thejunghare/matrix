import Stream, { type TransformOptions } from 'readable-stream';
import { Buffer } from '@craftzdog/react-native-buffer';
import type { BinaryLike, BinaryLikeNode, Encoding } from './utils';
import type { CipherCCMOptions, CipherCCMTypes, CipherGCMTypes, CipherGCMOptions, CipherOCBOptions, CipherOCBTypes } from 'crypto';
export type CipherOptions = CipherCCMOptions | CipherOCBOptions | CipherGCMOptions | TransformOptions;
export declare function getCiphers(): string[];
interface CipherArgs {
    isCipher: boolean;
    cipherType: string;
    cipherKey: BinaryLikeNode;
    iv: BinaryLike;
    options?: CipherOptions;
}
declare class CipherCommon extends Stream.Transform {
    private native;
    constructor({ isCipher, cipherType, cipherKey, iv, options }: CipherArgs);
    update(data: Buffer): Buffer;
    update(data: BinaryLike, inputEncoding?: Encoding): Buffer;
    update(data: BinaryLike, inputEncoding: Encoding, outputEncoding: Encoding): string;
    final(): Buffer;
    final(outputEncoding: BufferEncoding | 'buffer'): string;
    _transform(chunk: BinaryLike, encoding: BufferEncoding, callback: () => void): void;
    _flush(callback: () => void): void;
    setAutoPadding(autoPadding?: boolean): this;
    setAAD(buffer: Buffer, options?: {
        plaintextLength: number;
    }): this;
    getAuthTag(): Buffer;
    setAuthTag(tag: Buffer): this;
    getSupportedCiphers(): string[];
}
declare class Cipheriv extends CipherCommon {
    constructor(cipherType: string, cipherKey: BinaryLikeNode, iv: BinaryLike, options?: CipherOptions);
}
export type Cipher = Cipheriv;
declare class Decipheriv extends CipherCommon {
    constructor(cipherType: string, cipherKey: BinaryLikeNode, iv: BinaryLike, options?: CipherOptions);
}
export type Decipher = Decipheriv;
export declare function createDecipheriv(algorithm: CipherCCMTypes, key: BinaryLikeNode, iv: BinaryLike, options: CipherCCMOptions): Decipher;
export declare function createDecipheriv(algorithm: CipherOCBTypes, key: BinaryLikeNode, iv: BinaryLike, options: CipherOCBOptions): Decipher;
export declare function createDecipheriv(algorithm: CipherGCMTypes, key: BinaryLikeNode, iv: BinaryLike, options?: CipherGCMOptions): Decipher;
export declare function createDecipheriv(algorithm: string, key: BinaryLikeNode, iv: BinaryLike, options?: TransformOptions): Decipher;
export declare function createCipheriv(algorithm: CipherCCMTypes, key: BinaryLikeNode, iv: BinaryLike, options: CipherCCMOptions): Cipher;
export declare function createCipheriv(algorithm: CipherOCBTypes, key: BinaryLikeNode, iv: BinaryLike, options: CipherOCBOptions): Cipher;
export declare function createCipheriv(algorithm: CipherGCMTypes, key: BinaryLikeNode, iv: BinaryLike, options?: CipherGCMOptions): Cipher;
export declare function createCipheriv(algorithm: string, key: BinaryLikeNode, iv: BinaryLike, options?: TransformOptions): Cipher;
/**
 * xsalsa20 stream encryption with @noble/ciphers compatible API
 *
 * @param key - 32 bytes
 * @param nonce - 24 bytes
 * @param data - data to encrypt
 * @param output - unused
 * @param counter - unused
 * @returns encrypted data
 */
export declare function xsalsa20(key: Uint8Array, nonce: Uint8Array, data: Uint8Array, output?: Uint8Array | undefined, counter?: number): Uint8Array;
export {};
//# sourceMappingURL=cipher.d.ts.map