import { Stream } from 'readable-stream';
import type { TransformOptions } from 'readable-stream';
import type { BinaryLike, Encoding, BufferLike, SubtleAlgorithm } from './utils';
export declare function getHashes(): string[];
interface HashOptions extends TransformOptions {
    /**
     * For XOF hash functions such as `shake256`, the
     * outputLength option can be used to specify the desired output length in bytes.
     */
    outputLength?: number | undefined;
}
declare class Hash extends Stream.Transform {
    private algorithm;
    private options;
    private native;
    private validate;
    /**
     * @internal use `createHash()` instead
     */
    private constructor();
    /**
     * Updates the hash content with the given `data`, the encoding of which
     * is given in `inputEncoding`.
     * If `encoding` is not provided, and the `data` is a string, an
     * encoding of `'utf8'` is enforced. If `data` is a `Buffer`, `TypedArray`, or`DataView`, then `inputEncoding` is ignored.
     *
     * This can be called many times with new data as it is streamed.
     * @since v1.0.0
     * @param inputEncoding The `encoding` of the `data` string.
     */
    update(data: BinaryLike): Hash;
    update(data: BinaryLike, inputEncoding: Encoding): Buffer;
    /**
     * Calculates the digest of all of the data passed to be hashed (using the `hash.update()` method).
     * If `encoding` is provided a string will be returned; otherwise
     * a `Buffer` is returned.
     *
     * The `Hash` object can not be used again after `hash.digest()` method has been
     * called. Multiple calls will cause an error to be thrown.
     * @since v1.0.0
     * @param encoding The `encoding` of the return value.
     */
    digest(): Buffer;
    digest(encoding: Encoding): Buffer;
    /**
     * Creates a new `Hash` object that contains a deep copy of the internal state
     * of the current `Hash` object.
     *
     * The optional `options` argument controls stream behavior. For XOF hash
     * functions such as `'shake256'`, the `outputLength` option can be used to
     * specify the desired output length in bytes.
     *
     * An error is thrown when an attempt is made to copy the `Hash` object after
     * its `hash.digest()` method has been called.
     *
     * ```js
     * // Calculate a rolling hash.
     * import { createHash } from 'react-native-quick-crypto';
     *
     * const hash = createHash('sha256');
     *
     * hash.update('one');
     * console.log(hash.copy().digest('hex'));
     *
     * hash.update('two');
     * console.log(hash.copy().digest('hex'));
     *
     * hash.update('three');
     * console.log(hash.copy().digest('hex'));
     *
     * // Etc.
     * ```
     * @since v1.0.0
     * @param options `stream.transform` options
     */
    copy(): Hash;
    copy(options: HashOptions): Hash;
    /**
     * Returns the OpenSSL version string
     * @since v1.0.0
     */
    getOpenSSLVersion(): string;
    _transform(chunk: BinaryLike, encoding: BufferEncoding, callback: () => void): void;
    _flush(callback: () => void): void;
}
/**
 * Creates and returns a `Hash` object that can be used to generate hash digests
 * using the given `algorithm`. Optional `options` argument controls stream
 * behavior. For XOF hash functions such as `'shake256'`, the `outputLength` option
 * can be used to specify the desired output length in bytes.
 *
 * The `algorithm` is dependent on the available algorithms supported by the
 * version of OpenSSL on the platform. Examples are `'sha256'`, `'sha512'`, etc.
 * On recent releases of OpenSSL, `openssl list -digest-algorithms` will
 * display the available digest algorithms.
 *
 * Example: generating the sha256 sum of a file
 *
 * ```js
 * import crypto from 'react-native-quick-crypto';
 *
 * const hash = crypto.createHash('sha256').update('Test123').digest('hex');
 * console.log('SHA-256 of "Test123":', hash);
 * ```
 * @since v1.0.0
 * @param options `stream.transform` options
 */
export declare function createHash(algorithm: string, options?: HashOptions): Hash;
/**
 * Asynchronous digest function for WebCrypto SubtleCrypto API
 * @param algorithm The hash algorithm to use
 * @param data The data to hash
 * @returns Promise resolving to the hash digest as ArrayBuffer
 */
export declare const asyncDigest: (algorithm: SubtleAlgorithm, data: BufferLike) => Promise<ArrayBuffer>;
export declare const hashExports: {
    createHash: typeof createHash;
    getHashes: typeof getHashes;
    asyncDigest: (algorithm: SubtleAlgorithm, data: BufferLike) => Promise<ArrayBuffer>;
};
export {};
//# sourceMappingURL=hash.d.ts.map