import { Buffer } from '@craftzdog/react-native-buffer';
import * as keys from './keys';
import * as blake3 from './blake3';
import * as cipher from './cipher';
import * as ed from './ed';
import * as hkdf from './hkdf';
import * as scrypt from './scrypt';
import * as random from './random';
import * as utils from './utils';
import * as subtle from './subtle';
/**
 * Loosely matches Node.js {crypto} with some unimplemented functionality.
 * See `docs/implementation-coverage.md` for status.
 */
declare const QuickCrypto: {
    constants: {
        readonly RSA_PKCS1_PADDING: 1;
        readonly RSA_NO_PADDING: 3;
        readonly RSA_PKCS1_OAEP_PADDING: 4;
        readonly RSA_X931_PADDING: 5;
        readonly RSA_PKCS1_PSS_PADDING: 6;
        readonly RSA_PSS_SALTLEN_DIGEST: -1;
        readonly RSA_PSS_SALTLEN_MAX_SIGN: -2;
        readonly RSA_PSS_SALTLEN_AUTO: -2;
        readonly POINT_CONVERSION_COMPRESSED: 2;
        readonly POINT_CONVERSION_UNCOMPRESSED: 4;
        readonly POINT_CONVERSION_HYBRID: 6;
        readonly DH_CHECK_P_NOT_PRIME: 1;
        readonly DH_CHECK_P_NOT_SAFE_PRIME: 2;
        readonly DH_UNABLE_TO_CHECK_GENERATOR: 4;
        readonly DH_NOT_SUITABLE_GENERATOR: 8;
        readonly OPENSSL_VERSION_NUMBER: 805306368;
    };
    isCryptoKeyPair(result: keys.CryptoKey | utils.CryptoKeyPair): result is utils.CryptoKeyPair;
    Subtle: typeof subtle.Subtle;
    subtle: subtle.Subtle;
    toArrayBuffer(buf: Buffer | import("safe-buffer").Buffer | ArrayBufferView): ArrayBuffer;
    bufferLikeToArrayBuffer(buf: utils.BufferLike): ArrayBuffer;
    binaryLikeToArrayBuffer(input: utils.BinaryLikeNode, encoding?: string): ArrayBuffer;
    ab2str(buf: ArrayBuffer, encoding?: string): string;
    abvToArrayBuffer: (buf: utils.ABV) => ArrayBuffer;
    kEmptyObject: any;
    ensureBytes(title: string, hex: utils.Hex, expectedLength?: number): Uint8Array;
    isBytes(a: unknown): a is Uint8Array;
    hexToBytes(hex: string): Uint8Array;
    lazyDOMException(message: string, domName: string | {
        name: string;
        cause: unknown;
    }): Error;
    normalizeHashName(algo: string | utils.HashAlgorithm | {
        name: string;
    } | undefined, context?: utils.HashContext): utils.HashAlgorithm;
    HashContext: typeof utils.HashContext;
    timingSafeEqual(a: utils.ABV, b: utils.ABV): boolean;
    KFormatType: typeof utils.KFormatType;
    KeyType: typeof utils.KeyType;
    KeyEncoding: typeof utils.KeyEncoding;
    KeyFormat: typeof utils.KeyFormat;
    kNamedCurveAliases: {
        readonly 'P-256': "prime256v1";
        readonly 'P-384': "secp384r1";
        readonly 'P-521': "secp521r1";
    };
    KeyVariant: typeof utils.KeyVariant;
    validateFunction(f: unknown): boolean;
    isStringOrBuffer(val: unknown): val is string | ArrayBuffer;
    validateObject<T>(value: unknown, name: string, options?: {
        allowArray: boolean;
        allowFunction: boolean;
        nullable: boolean;
    } | null): value is T;
    hasAnyNotIn(set: string[], checks: string[]): boolean;
    validateMaxBufferLength: (data: utils.BinaryLike | utils.BufferLike, name: string) => void;
    getUsagesUnion: (usageSet: utils.KeyUsage[], ...usages: utils.KeyUsage[]) => utils.KeyUsage[];
    validateKeyOps: (keyOps: utils.KeyUsage[] | undefined, usagesSet: utils.KeyUsage[]) => void;
    setDefaultEncoding(encoding: utils.Encoding): void;
    getDefaultEncoding(): utils.Encoding;
    normalizeEncoding(enc: string): "ascii" | "utf8" | "utf16le" | "base64" | "latin1" | "hex" | undefined;
    validateEncoding(data: string, encoding: string): void;
    getUIntOption(options: Record<string, any>, key: string): any;
    randomFill<T extends utils.ABV>(buffer: T, callback: utils.RandomCallback<T>): void;
    randomFill<T extends utils.ABV>(buffer: T, offset: number, callback: utils.RandomCallback<T>): void;
    randomFill<T extends utils.ABV>(buffer: T, offset: number, size: number, callback: utils.RandomCallback<T>): void;
    randomFillSync<T extends utils.ABV>(buffer: T, offset?: number, size?: number): T;
    randomBytes(size: number): Buffer;
    randomBytes(size: number, callback: (err: Error | null, buf?: Buffer) => void): void;
    randomInt(max: number, callback: (err: Error | null, value: number) => void): void;
    randomInt(max: number): number;
    randomInt(min: number, max: number, callback: (err: Error | null, value: number) => void): void;
    randomInt(min: number, max: number): number;
    getRandomValues(data: random.RandomTypedArrays): random.RandomTypedArrays;
    randomUUID(): string;
    rng: typeof random.randomBytes;
    pseudoRandomBytes: typeof random.randomBytes;
    prng: typeof random.randomBytes;
    scrypt(password: utils.BinaryLike, salt: utils.BinaryLike, keylen: number, options?: scrypt.ScryptOptions | ((err: Error | null, derivedKey?: Buffer) => void), callback?: (err: Error | null, derivedKey?: Buffer) => void): void;
    scryptSync(password: utils.BinaryLike, salt: utils.BinaryLike, keylen: number, options?: scrypt.ScryptOptions): Buffer;
    pbkdf2(password: utils.BinaryLike, salt: utils.BinaryLike, iterations: number, keylen: number, digest: string, callback: (err: Error | null, derivedKey?: Buffer) => void): void;
    pbkdf2Sync(password: utils.BinaryLike, salt: utils.BinaryLike, iterations: number, keylen: number, digest?: utils.HashAlgorithm): Buffer;
    pbkdf2DeriveBits(algorithm: utils.SubtleAlgorithm, baseKey: keys.CryptoKey, length: number): Promise<ArrayBuffer>;
    hkdf(digest: string, key: utils.BinaryLike, salt: utils.BinaryLike, info: utils.BinaryLike, keylen: number, callback: hkdf.HkdfCallback): void;
    hkdfSync(digest: string, key: utils.BinaryLike, salt: utils.BinaryLike, info: utils.BinaryLike, keylen: number): Buffer;
    hkdfDeriveBits(algorithm: hkdf.HkdfAlgorithm, baseKey: hkdf.CryptoKeyInternal, length: number): ArrayBuffer;
    createHmac: typeof import("./hmac").createHmac;
    createHash: typeof import("./hash").createHash;
    getHashes: typeof import("./hash").getHashes;
    asyncDigest: (algorithm: utils.SubtleAlgorithm, data: utils.BufferLike) => Promise<ArrayBuffer>;
    diffieHellman(options: utils.DiffieHellmanOptions, callback?: utils.DiffieHellmanCallback): Buffer | void;
    ed_generateKeyPair(isAsync: boolean, type: utils.CFRGKeyPairType, encoding: utils.KeyPairGenConfig, callback: utils.GenerateKeyPairCallback | undefined): utils.GenerateKeyPairReturn | void;
    ed_generateKeyPairWebCrypto(type: "ed25519" | "ed448", extractable: boolean, keyUsages: utils.KeyUsage[]): Promise<utils.CryptoKeyPair>;
    x_generateKeyPairWebCrypto(type: "x25519" | "x448", extractable: boolean, keyUsages: utils.KeyUsage[]): Promise<utils.CryptoKeyPair>;
    xDeriveBits(algorithm: utils.SubtleAlgorithm, baseKey: keys.CryptoKey, length: number | null): ArrayBuffer;
    Ed: typeof ed.Ed;
    getCiphers(): string[];
    createDecipheriv(algorithm: import("crypto").CipherCCMTypes, key: utils.BinaryLikeNode, iv: utils.BinaryLike, options: import("crypto").CipherCCMOptions): cipher.Decipher;
    createDecipheriv(algorithm: import("crypto").CipherOCBTypes, key: utils.BinaryLikeNode, iv: utils.BinaryLike, options: import("crypto").CipherOCBOptions): cipher.Decipher;
    createDecipheriv(algorithm: import("crypto").CipherGCMTypes, key: utils.BinaryLikeNode, iv: utils.BinaryLike, options?: import("crypto").CipherGCMOptions): cipher.Decipher;
    createDecipheriv(algorithm: string, key: utils.BinaryLikeNode, iv: utils.BinaryLike, options?: import("readable-stream").TransformOptions): cipher.Decipher;
    createCipheriv(algorithm: import("crypto").CipherCCMTypes, key: utils.BinaryLikeNode, iv: utils.BinaryLike, options: import("crypto").CipherCCMOptions): cipher.Cipher;
    createCipheriv(algorithm: import("crypto").CipherOCBTypes, key: utils.BinaryLikeNode, iv: utils.BinaryLike, options: import("crypto").CipherOCBOptions): cipher.Cipher;
    createCipheriv(algorithm: import("crypto").CipherGCMTypes, key: utils.BinaryLikeNode, iv: utils.BinaryLike, options?: import("crypto").CipherGCMOptions): cipher.Cipher;
    createCipheriv(algorithm: string, key: utils.BinaryLikeNode, iv: utils.BinaryLike, options?: import("readable-stream").TransformOptions): cipher.Cipher;
    xsalsa20(key: Uint8Array, nonce: Uint8Array, data: Uint8Array, output?: Uint8Array | undefined, counter?: number): Uint8Array;
    createBlake3(opts?: blake3.Blake3Options): blake3.Blake3;
    blake3: typeof blake3.blake3;
    Blake3: typeof blake3.Blake3;
    blake3Exports: {
        Blake3: typeof blake3.Blake3;
        createBlake3: typeof blake3.createBlake3;
        blake3: typeof blake3.blake3;
    };
    createSecretKey: typeof keys.createSecretKey;
    createPublicKey: typeof keys.createPublicKey;
    createPrivateKey: typeof keys.createPrivateKey;
    CryptoKey: typeof keys.CryptoKey;
    generateKey: typeof keys.generateKey;
    generateKeySync: typeof keys.generateKeySync;
    generateKeyPair: (type: utils.KeyPairType, options: utils.GenerateKeyPairOptions, callback: utils.GenerateKeyPairCallback) => void;
    generateKeyPairSync: typeof keys.generateKeyPairSync;
    AsymmetricKeyObject: typeof keys.AsymmetricKeyObject;
    KeyObject: typeof keys.KeyObject;
    createSign: typeof keys.createSign;
    createVerify: typeof keys.createVerify;
    Sign: typeof keys.Sign;
    Verify: typeof keys.Verify;
    publicEncrypt: typeof keys.publicEncrypt;
    publicDecrypt: typeof keys.publicDecrypt;
    privateEncrypt: typeof keys.privateEncrypt;
    privateDecrypt: typeof keys.privateDecrypt;
    parsePublicKeyEncoding: typeof keys.parsePublicKeyEncoding;
    parsePrivateKeyEncoding: typeof keys.parsePrivateKeyEncoding;
    parseKeyEncoding: typeof keys.parseKeyEncoding;
    SecretKeyObject: typeof keys.SecretKeyObject;
    PublicKeyObject: typeof keys.PublicKeyObject;
    PrivateKeyObject: typeof keys.PrivateKeyObject;
    isCryptoKey: (obj: any) => boolean;
};
/**
 * Optional. Patch global.crypto with react-native-quick-crypto and
 * global.Buffer with react-native-buffer.
 */
export declare const install: () => void;
export default QuickCrypto;
export * from './blake3';
export * from './cipher';
export * from './ed';
export * from './keys';
export * from './hash';
export * from './hmac';
export * from './hkdf';
export * from './pbkdf2';
export * from './scrypt';
export * from './random';
export * from './utils';
export * from './subtle';
export { subtle, isCryptoKeyPair } from './subtle';
export { constants } from './constants';
//# sourceMappingURL=index.d.ts.map