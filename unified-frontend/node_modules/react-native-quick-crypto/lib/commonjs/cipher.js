"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCipheriv = createCipheriv;
exports.createDecipheriv = createDecipheriv;
exports.getCiphers = getCiphers;
exports.xsalsa20 = xsalsa20;
var _reactNativeNitroModules = require("react-native-nitro-modules");
var _readableStream = _interopRequireDefault(require("readable-stream"));
var _reactNativeBuffer = require("@craftzdog/react-native-buffer");
var _utils = require("./utils");
var _cipher = require("./utils/cipher");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
// @types/node

class CipherUtils {
  static native = _reactNativeNitroModules.NitroModules.createHybridObject('Cipher');
  static getSupportedCiphers() {
    return this.native.getSupportedCiphers();
  }
}
function getCiphers() {
  return CipherUtils.getSupportedCiphers();
}
class CipherCommon extends _readableStream.default.Transform {
  constructor({
    isCipher,
    cipherType,
    cipherKey,
    iv,
    options
  }) {
    // Explicitly create TransformOptions for super()
    const streamOptions = {};
    if (options) {
      // List known TransformOptions keys (adjust if needed)
      const transformKeys = ['readableHighWaterMark', 'writableHighWaterMark', 'decodeStrings', 'defaultEncoding', 'objectMode', 'destroy', 'read', 'write', 'writev', 'final', 'transform', 'flush'
      // Add any other relevant keys from readable-stream's TransformOptions
      ];
      for (const key of transformKeys) {
        if (key in options) {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          streamOptions[key] = options[key];
        }
      }
    }
    super(streamOptions); // Pass filtered options

    const authTagLen = (0, _cipher.getUIntOption)(options ?? {}, 'authTagLength') !== -1 ? (0, _cipher.getUIntOption)(options ?? {}, 'authTagLength') : 16; // defaults to 16 bytes

    const factory = _reactNativeNitroModules.NitroModules.createHybridObject('CipherFactory');
    this.native = factory.createCipher({
      isCipher,
      cipherType,
      cipherKey: (0, _utils.binaryLikeToArrayBuffer)(cipherKey),
      iv: (0, _utils.binaryLikeToArrayBuffer)(iv),
      authTagLen
    });
  }
  update(data, inputEncoding, outputEncoding) {
    const defaultEncoding = (0, _cipher.getDefaultEncoding)();
    inputEncoding = inputEncoding ?? defaultEncoding;
    outputEncoding = outputEncoding ?? defaultEncoding;
    if (typeof data === 'string') {
      (0, _cipher.validateEncoding)(data, inputEncoding);
    } else if (!ArrayBuffer.isView(data)) {
      throw new Error('Invalid data argument');
    }
    const ret = this.native.update((0, _utils.binaryLikeToArrayBuffer)(data, inputEncoding));
    if (outputEncoding && outputEncoding !== 'buffer') {
      return (0, _utils.ab2str)(ret, outputEncoding);
    }
    return _reactNativeBuffer.Buffer.from(ret);
  }
  final(outputEncoding) {
    const ret = this.native.final();
    if (outputEncoding && outputEncoding !== 'buffer') {
      return (0, _utils.ab2str)(ret, outputEncoding);
    }
    return _reactNativeBuffer.Buffer.from(ret);
  }
  _transform(chunk, encoding, callback) {
    this.push(this.update(chunk, (0, _cipher.normalizeEncoding)(encoding)));
    callback();
  }
  _flush(callback) {
    this.push(this.final());
    callback();
  }
  setAutoPadding(autoPadding) {
    const res = this.native.setAutoPadding(!!autoPadding);
    if (!res) {
      throw new Error('setAutoPadding failed');
    }
    return this;
  }
  setAAD(buffer, options) {
    // Check if native parts are initialized
    if (!this.native || typeof this.native.setAAD !== 'function') {
      throw new Error('Cipher native object or setAAD method not initialized.');
    }
    const res = this.native.setAAD(buffer.buffer, options?.plaintextLength);
    if (!res) {
      throw new Error('setAAD failed (native call returned false)');
    }
    return this;
  }
  getAuthTag() {
    return _reactNativeBuffer.Buffer.from(this.native.getAuthTag());
  }
  setAuthTag(tag) {
    const res = this.native.setAuthTag((0, _utils.binaryLikeToArrayBuffer)(tag));
    if (!res) {
      throw new Error('setAuthTag failed');
    }
    return this;
  }
  getSupportedCiphers() {
    return this.native.getSupportedCiphers();
  }
}
class Cipheriv extends CipherCommon {
  constructor(cipherType, cipherKey, iv, options) {
    super({
      isCipher: true,
      cipherType,
      cipherKey: (0, _utils.binaryLikeToArrayBuffer)(cipherKey),
      iv: (0, _utils.binaryLikeToArrayBuffer)(iv),
      options
    });
  }
}
class Decipheriv extends CipherCommon {
  constructor(cipherType, cipherKey, iv, options) {
    super({
      isCipher: false,
      cipherType,
      cipherKey: (0, _utils.binaryLikeToArrayBuffer)(cipherKey),
      iv: (0, _utils.binaryLikeToArrayBuffer)(iv),
      options
    });
  }
}
function createDecipheriv(algorithm, key, iv, options) {
  return new Decipheriv(algorithm, key, iv, options);
}
function createCipheriv(algorithm, key, iv, options) {
  return new Cipheriv(algorithm, key, iv, options);
}

/**
 * xsalsa20 stream encryption with @noble/ciphers compatible API
 *
 * @param key - 32 bytes
 * @param nonce - 24 bytes
 * @param data - data to encrypt
 * @param output - unused
 * @param counter - unused
 * @returns encrypted data
 */
function xsalsa20(key, nonce, data,
// @ts-expect-error haven't implemented this part of @noble/ciphers API
// eslint-disable-next-line @typescript-eslint/no-unused-vars
output,
// @ts-expect-error haven't implemented this part of @noble/ciphers API
// eslint-disable-next-line @typescript-eslint/no-unused-vars
counter) {
  const factory = _reactNativeNitroModules.NitroModules.createHybridObject('CipherFactory');
  const native = factory.createCipher({
    isCipher: true,
    cipherType: 'xsalsa20',
    cipherKey: (0, _utils.binaryLikeToArrayBuffer)(key),
    iv: (0, _utils.binaryLikeToArrayBuffer)(nonce)
  });
  const result = native.update((0, _utils.binaryLikeToArrayBuffer)(data));
  return new Uint8Array(result);
}
//# sourceMappingURL=cipher.js.map