"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MlDsa = void 0;
exports.mldsa_generateKeyPairWebCrypto = mldsa_generateKeyPairWebCrypto;
var _reactNativeNitroModules = require("react-native-nitro-modules");
var _keys = require("./keys");
var _utils = require("./utils");
class MlDsa {
  constructor(variant) {
    this.variant = variant;
    this.native = _reactNativeNitroModules.NitroModules.createHybridObject('MlDsaKeyPair');
    this.native.setVariant(variant);
  }
  async generateKeyPair() {
    await this.native.generateKeyPair(_utils.KFormatType.DER, _utils.KeyEncoding.SPKI, _utils.KFormatType.DER, _utils.KeyEncoding.PKCS8);
  }
  generateKeyPairSync() {
    this.native.generateKeyPairSync(_utils.KFormatType.DER, _utils.KeyEncoding.SPKI, _utils.KFormatType.DER, _utils.KeyEncoding.PKCS8);
  }
  getPublicKey() {
    return this.native.getPublicKey();
  }
  getPrivateKey() {
    return this.native.getPrivateKey();
  }
  async sign(message) {
    return this.native.sign(message);
  }
  signSync(message) {
    return this.native.signSync(message);
  }
  async verify(signature, message) {
    return this.native.verify(signature, message);
  }
  verifySync(signature, message) {
    return this.native.verifySync(signature, message);
  }
}
exports.MlDsa = MlDsa;
async function mldsa_generateKeyPairWebCrypto(variant, extractable, keyUsages) {
  if ((0, _utils.hasAnyNotIn)(keyUsages, ['sign', 'verify'])) {
    throw (0, _utils.lazyDOMException)(`Unsupported key usage for ${variant}`, 'SyntaxError');
  }
  const publicUsages = (0, _utils.getUsagesUnion)(keyUsages, 'verify');
  const privateUsages = (0, _utils.getUsagesUnion)(keyUsages, 'sign');
  if (privateUsages.length === 0) {
    throw (0, _utils.lazyDOMException)('Usages cannot be empty', 'SyntaxError');
  }
  const mldsa = new MlDsa(variant);
  await mldsa.generateKeyPair();
  const publicKeyData = mldsa.getPublicKey();
  const privateKeyData = mldsa.getPrivateKey();
  const pub = _keys.KeyObject.createKeyObject('public', publicKeyData, _utils.KFormatType.DER, _utils.KeyEncoding.SPKI);
  const publicKey = new _keys.CryptoKey(pub, {
    name: variant
  }, publicUsages, true);
  const priv = _keys.KeyObject.createKeyObject('private', privateKeyData, _utils.KFormatType.DER, _utils.KeyEncoding.PKCS8);
  const privateKey = new _keys.CryptoKey(priv, {
    name: variant
  }, privateUsages, extractable);
  return {
    publicKey,
    privateKey
  };
}
//# sourceMappingURL=mldsa.js.map