"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefaultEncoding = getDefaultEncoding;
exports.getUIntOption = getUIntOption;
exports.normalizeEncoding = normalizeEncoding;
exports.setDefaultEncoding = setDefaultEncoding;
exports.validateEncoding = validateEncoding;
// Mimics node behavior for default global encoding
let defaultEncoding = 'buffer';
function setDefaultEncoding(encoding) {
  defaultEncoding = encoding;
}
function getDefaultEncoding() {
  return defaultEncoding;
}
function normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  let retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
}
function validateEncoding(data, encoding) {
  const normalizedEncoding = normalizeEncoding(encoding);
  const length = data.length;
  if (normalizedEncoding === 'hex' && length % 2 !== 0) {
    throw new Error(`Encoding ${encoding} not valid for data length ${length}`);
  }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function getUIntOption(options, key) {
  let value;
  if (options && (value = options[key]) != null) {
    // >>> Turns any type into a positive integer (also sets the sign bit to 0)
    if (value >>> 0 !== value) throw new Error(`options.${key}: ${value}`);
    return value;
  }
  return -1;
}
//# sourceMappingURL=cipher.js.map