"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  abvToArrayBuffer: true,
  toArrayBuffer: true,
  bufferLikeToArrayBuffer: true,
  binaryLikeToArrayBuffer: true,
  ab2str: true,
  kEmptyObject: true
};
exports.ab2str = ab2str;
exports.abvToArrayBuffer = void 0;
exports.binaryLikeToArrayBuffer = binaryLikeToArrayBuffer;
exports.bufferLikeToArrayBuffer = bufferLikeToArrayBuffer;
exports.kEmptyObject = void 0;
exports.toArrayBuffer = toArrayBuffer;
var _reactNativeBuffer = require("@craftzdog/react-native-buffer");
var _safeBuffer = require("safe-buffer");
var _classes = require("../keys/classes");
var _noble = require("./noble");
Object.keys(_noble).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _noble[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _noble[key];
    }
  });
});
/**
 * Converts supplied argument to an ArrayBuffer.  Note this does not copy the
 * data so it is faster than toArrayBuffer.  Not copying is important for
 * functions like randomFill which need to be able to write to the underlying
 * buffer.
 * @param buf
 * @returns ArrayBuffer
 */
const abvToArrayBuffer = buf => {
  if (_reactNativeBuffer.Buffer.isBuffer(buf)) {
    return buf.buffer;
  }
  if (ArrayBuffer.isView(buf)) {
    return buf.buffer;
  }
  return buf;
};

/**
 * Converts supplied argument to an ArrayBuffer.  Note this copies data if the
 * supplied buffer has the .slice() method, so can be a bit slow.
 * @param buf
 * @returns ArrayBuffer
 */
exports.abvToArrayBuffer = abvToArrayBuffer;
function toArrayBuffer(buf) {
  if (_reactNativeBuffer.Buffer.isBuffer(buf) || ArrayBuffer.isView(buf)) {
    if (buf?.buffer?.slice) {
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    } else {
      return buf.buffer;
    }
  }
  const ab = new ArrayBuffer(buf.length);
  const view = new Uint8Array(ab);
  for (let i = 0; i < buf.length; ++i) {
    view[i] = _safeBuffer.Buffer.isBuffer(buf) ? buf.readUInt8(i) : buf[i];
  }
  return ab;
}
function bufferLikeToArrayBuffer(buf) {
  // Buffer
  if (_reactNativeBuffer.Buffer.isBuffer(buf) || _safeBuffer.Buffer.isBuffer(buf)) {
    return toArrayBuffer(buf);
  }
  // ArrayBufferView
  if (ArrayBuffer.isView(buf)) {
    return toArrayBuffer(buf);
  }

  // If buf is already an ArrayBuffer, return it.
  if (buf instanceof ArrayBuffer) {
    return buf;
  }

  // If buf is a SharedArrayBuffer, convert it to ArrayBuffer.
  // This typically involves a copy of the data.
  if (typeof SharedArrayBuffer !== 'undefined' && buf instanceof SharedArrayBuffer) {
    const arrayBuffer = new ArrayBuffer(buf.byteLength);
    new Uint8Array(arrayBuffer).set(new Uint8Array(buf));
    return arrayBuffer;
  }

  // If we reach here, 'buf' is of a type within BufferLike that has not been handled by the above checks.
  // This indicates either an incomplete BufferLike definition or an unexpected input type.
  // Throw an error to signal this, ensuring the function's contract (return ArrayBuffer or throw) is met.
  throw new TypeError('Input must be a Buffer, ArrayBufferView, ArrayBuffer, or SharedArrayBuffer.');
}
function binaryLikeToArrayBuffer(input,
// CipherKey adds compat with node types
encoding = 'utf-8') {
  // string
  if (typeof input === 'string') {
    if (encoding === 'buffer') {
      throw new Error('Cannot create a buffer from a string with a buffer encoding');
    }
    const buffer = _reactNativeBuffer.Buffer.from(input, encoding);
    return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
  }

  // Buffer
  if (_reactNativeBuffer.Buffer.isBuffer(input) || _safeBuffer.Buffer.isBuffer(input)) {
    return toArrayBuffer(input);
  }

  // ArrayBufferView
  // TODO add further binary types to BinaryLike, UInt8Array and so for have this array as property
  if (ArrayBuffer.isView(input)) {
    return toArrayBuffer(input);
  }

  // ArrayBuffer
  if (input instanceof ArrayBuffer) {
    return input;
  }

  // if (!(input instanceof ArrayBuffer)) {
  //   try {
  //     // this is a strange fallback case and input is unknown at this point
  //     const buffer = Buffer.from(input as unknown as string);
  //     return buffer.buffer.slice(
  //       buffer.byteOffset,
  //       buffer.byteOffset + buffer.byteLength
  //     );
  //   } catch(e: unknown) {
  //     console.log('throwing 1');
  //     const err = e as Error;
  //     throw new Error(err.message);
  //   }
  // }

  // KeyObject
  if (input instanceof _classes.KeyObject) {
    return input.handle.exportKey();
  }
  throw new Error('Invalid argument type for "key". Need ArrayBuffer, TypedArray, KeyObject, CryptoKey, string');
}
function ab2str(buf, encoding = 'hex') {
  return _reactNativeBuffer.Buffer.from(buf).toString(encoding);
}
const kEmptyObject = exports.kEmptyObject = Object.freeze(Object.create(null));
//# sourceMappingURL=conversion.js.map