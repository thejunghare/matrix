"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AsymmetricKeyObject", {
  enumerable: true,
  get: function () {
    return _classes.AsymmetricKeyObject;
  }
});
Object.defineProperty(exports, "CryptoKey", {
  enumerable: true,
  get: function () {
    return _classes.CryptoKey;
  }
});
Object.defineProperty(exports, "KeyObject", {
  enumerable: true,
  get: function () {
    return _classes.KeyObject;
  }
});
Object.defineProperty(exports, "PrivateKeyObject", {
  enumerable: true,
  get: function () {
    return _classes.PrivateKeyObject;
  }
});
Object.defineProperty(exports, "PublicKeyObject", {
  enumerable: true,
  get: function () {
    return _classes.PublicKeyObject;
  }
});
Object.defineProperty(exports, "SecretKeyObject", {
  enumerable: true,
  get: function () {
    return _classes.SecretKeyObject;
  }
});
Object.defineProperty(exports, "Sign", {
  enumerable: true,
  get: function () {
    return _signVerify.Sign;
  }
});
Object.defineProperty(exports, "Verify", {
  enumerable: true,
  get: function () {
    return _signVerify.Verify;
  }
});
exports.createPrivateKey = createPrivateKey;
exports.createPublicKey = createPublicKey;
exports.createSecretKey = createSecretKey;
Object.defineProperty(exports, "createSign", {
  enumerable: true,
  get: function () {
    return _signVerify.createSign;
  }
});
Object.defineProperty(exports, "createVerify", {
  enumerable: true,
  get: function () {
    return _signVerify.createVerify;
  }
});
exports.generateKey = generateKey;
Object.defineProperty(exports, "generateKeyPair", {
  enumerable: true,
  get: function () {
    return _generateKeyPair.generateKeyPair;
  }
});
Object.defineProperty(exports, "generateKeyPairSync", {
  enumerable: true,
  get: function () {
    return _generateKeyPair.generateKeyPairSync;
  }
});
exports.generateKeySync = generateKeySync;
Object.defineProperty(exports, "isCryptoKey", {
  enumerable: true,
  get: function () {
    return _utils.isCryptoKey;
  }
});
Object.defineProperty(exports, "parseKeyEncoding", {
  enumerable: true,
  get: function () {
    return _utils.parseKeyEncoding;
  }
});
Object.defineProperty(exports, "parsePrivateKeyEncoding", {
  enumerable: true,
  get: function () {
    return _utils.parsePrivateKeyEncoding;
  }
});
Object.defineProperty(exports, "parsePublicKeyEncoding", {
  enumerable: true,
  get: function () {
    return _utils.parsePublicKeyEncoding;
  }
});
Object.defineProperty(exports, "privateDecrypt", {
  enumerable: true,
  get: function () {
    return _publicCipher.privateDecrypt;
  }
});
Object.defineProperty(exports, "privateEncrypt", {
  enumerable: true,
  get: function () {
    return _publicCipher.privateEncrypt;
  }
});
Object.defineProperty(exports, "publicDecrypt", {
  enumerable: true,
  get: function () {
    return _publicCipher.publicDecrypt;
  }
});
Object.defineProperty(exports, "publicEncrypt", {
  enumerable: true,
  get: function () {
    return _publicCipher.publicEncrypt;
  }
});
var _classes = require("./classes");
var _generateKeyPair = require("./generateKeyPair");
var _signVerify = require("./signVerify");
var _publicCipher = require("./publicCipher");
var _utils = require("./utils");
var _utils2 = require("../utils");
var _random = require("../random");
function createSecretKey(key) {
  const keyBuffer = (0, _utils2.binaryLikeToArrayBuffer)(key);
  return _classes.KeyObject.createKeyObject('secret', keyBuffer);
}
function prepareAsymmetricKey(key, isPublic) {
  if (key instanceof _classes.KeyObject) {
    if (isPublic) {
      // createPublicKey can accept either a public key or extract public from private
      if (key.type === 'secret') {
        throw new Error('Cannot create public key from secret key');
      }
      // Export as SPKI (public key format) - works for both public and private keys
      const exported = key.handle.exportKey(_utils2.KFormatType.DER, _utils2.KeyEncoding.SPKI);
      return {
        data: exported,
        format: 'der',
        type: 'spki'
      };
    } else {
      // createPrivateKey requires a private key
      if (key.type !== 'private') {
        throw new Error('Key must be a private key');
      }
      const exported = key.handle.exportKey(_utils2.KFormatType.DER, _utils2.KeyEncoding.PKCS8);
      return {
        data: exported,
        format: 'der',
        type: 'pkcs8'
      };
    }
  }
  if ((0, _utils.isCryptoKey)(key)) {
    const cryptoKey = key;
    return prepareAsymmetricKey(cryptoKey.keyObject, isPublic);
  }
  if ((0, _utils2.isStringOrBuffer)(key)) {
    // Detect PEM format from string content
    const isPem = typeof key === 'string' && key.includes('-----BEGIN');
    return {
      data: (0, _utils2.binaryLikeToArrayBuffer)(key),
      format: isPem ? 'pem' : undefined
    };
  }
  if (typeof key === 'object' && 'key' in key) {
    const keyObj = key;
    const {
      key: data,
      format,
      type
    } = keyObj;
    if (data instanceof _classes.KeyObject) {
      return prepareAsymmetricKey(data, isPublic);
    }
    if ((0, _utils.isCryptoKey)(data)) {
      return prepareAsymmetricKey(data.keyObject, isPublic);
    }
    if (!(0, _utils2.isStringOrBuffer)(data)) {
      throw new Error('Invalid key data type');
    }

    // For PEM format with string data, convert to ArrayBuffer
    if ((format === 'pem' || typeof data === 'string' && data.includes('-----BEGIN')) && typeof data === 'string') {
      return {
        data: (0, _utils2.binaryLikeToArrayBuffer)(data),
        format: 'pem',
        type
      };
    }

    // Filter out 'jwk' format - only 'pem' and 'der' are supported here
    const filteredFormat = format === 'jwk' ? undefined : format;
    return {
      data: (0, _utils2.binaryLikeToArrayBuffer)(data),
      format: filteredFormat,
      type
    };
  }
  throw new Error('Invalid key input');
}
function createPublicKey(key) {
  const {
    data,
    format,
    type
  } = prepareAsymmetricKey(key, true);

  // Map format string to KFormatType enum
  let kFormat;
  if (format === 'pem') kFormat = _utils2.KFormatType.PEM;else if (format === 'der') kFormat = _utils2.KFormatType.DER;

  // Map type string to KeyEncoding enum
  let kType;
  if (type === 'spki') kType = _utils2.KeyEncoding.SPKI;else if (type === 'pkcs1') kType = _utils2.KeyEncoding.PKCS1;
  return _classes.KeyObject.createKeyObject('public', data, kFormat, kType);
}
function createPrivateKey(key) {
  const {
    data,
    format,
    type
  } = prepareAsymmetricKey(key, false);

  // Map format string to KFormatType enum
  let kFormat;
  if (format === 'pem') kFormat = _utils2.KFormatType.PEM;else if (format === 'der') kFormat = _utils2.KFormatType.DER;

  // Map type string to KeyEncoding enum
  let kType;
  if (type === 'pkcs8') kType = _utils2.KeyEncoding.PKCS8;else if (type === 'pkcs1') kType = _utils2.KeyEncoding.PKCS1;else if (type === 'sec1') kType = _utils2.KeyEncoding.SEC1;
  return _classes.KeyObject.createKeyObject('private', data, kFormat, kType);
}
function generateKeySync(type, options) {
  if (typeof type !== 'string') {
    throw new TypeError('The "type" argument must be a string');
  }
  if (typeof options !== 'object' || options === null) {
    throw new TypeError('The "options" argument must be an object');
  }
  const {
    length
  } = options;
  if (typeof length !== 'number' || !Number.isInteger(length)) {
    throw new TypeError('The "options.length" property must be an integer');
  }
  switch (type) {
    case 'hmac':
      if (length < 8 || length > 2 ** 31 - 1) {
        throw new RangeError('The "options.length" property must be >= 8 and <= 2147483647');
      }
      break;
    case 'aes':
      if (length !== 128 && length !== 192 && length !== 256) {
        throw new RangeError('The "options.length" property must be 128, 192, or 256');
      }
      break;
    default:
      throw new TypeError(`The "type" argument must be 'aes' or 'hmac'. Received '${type}'`);
  }
  const keyBytes = length / 8;
  const keyMaterial = (0, _random.randomBytes)(keyBytes);
  return createSecretKey(keyMaterial);
}
function generateKey(type, options, callback) {
  if (typeof callback !== 'function') {
    throw new TypeError('The "callback" argument must be a function');
  }
  try {
    const key = generateKeySync(type, options);
    process.nextTick(callback, null, key);
  } catch (err) {
    process.nextTick(callback, err);
  }
}
//# sourceMappingURL=index.js.map