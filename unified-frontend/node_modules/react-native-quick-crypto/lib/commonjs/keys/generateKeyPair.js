"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateKeyPairPromise = exports.generateKeyPair = void 0;
exports.generateKeyPairSync = generateKeyPairSync;
var _ed = require("../ed");
var _rsa = require("../rsa");
var _ec = require("../ec");
var _utils = require("../utils");
var _utils2 = require("./utils");
const generateKeyPair = (type, options, callback) => {
  (0, _utils.validateFunction)(callback);
  internalGenerateKeyPair(true, type, options, callback);
};

// Promisify generateKeyPair
// (attempted to use util.promisify, to no avail)
exports.generateKeyPair = generateKeyPair;
const generateKeyPairPromise = (type, options) => {
  return new Promise((resolve, reject) => {
    generateKeyPair(type, options, (err, publicKey, privateKey) => {
      if (err) {
        reject([err, undefined]);
      } else {
        resolve([undefined, {
          publicKey,
          privateKey
        }]);
      }
    });
  });
};

// generateKeyPairSync
exports.generateKeyPairPromise = generateKeyPairPromise;
function generateKeyPairSync(type, options) {
  const [err, publicKey, privateKey] = internalGenerateKeyPair(false, type, options, undefined);
  if (err) {
    throw err;
  }
  return {
    publicKey,
    privateKey
  };
}
function parseKeyPairEncoding(keyType, options = _utils.kEmptyObject) {
  const {
    publicKeyEncoding,
    privateKeyEncoding
  } = options;
  let publicFormat, publicType;
  if (publicKeyEncoding == null) {
    publicFormat = publicType = -1;
  } else if (typeof publicKeyEncoding === 'object') {
    ({
      format: publicFormat,
      type: publicType
    } = (0, _utils2.parsePublicKeyEncoding)(publicKeyEncoding, keyType, 'publicKeyEncoding'));
  } else {
    throw new Error('Invalid argument options.publicKeyEncoding', publicKeyEncoding);
  }
  let privateFormat, privateType, cipher, passphrase;
  if (privateKeyEncoding == null) {
    privateFormat = privateType = -1;
  } else if (typeof privateKeyEncoding === 'object') {
    ({
      format: privateFormat,
      type: privateType,
      cipher,
      passphrase
    } = (0, _utils2.parsePrivateKeyEncoding)(privateKeyEncoding, keyType, 'privateKeyEncoding'));
  } else {
    throw new Error('Invalid argument options.privateKeyEncoding', publicKeyEncoding);
  }
  return {
    publicFormat,
    publicType,
    privateFormat,
    privateType,
    cipher,
    passphrase
  };
}
function internalGenerateKeyPair(isAsync, type, options, callback) {
  const encoding = parseKeyPairEncoding(type, options);
  switch (type) {
    case 'ed25519':
    case 'ed448':
    case 'x25519':
    case 'x448':
      return (0, _ed.ed_generateKeyPair)(isAsync, type, encoding, callback);
    case 'rsa':
    case 'rsa-pss':
    case 'dsa':
    case 'ec':
      break;
    default:
      {
        const err = new Error(`
        Invalid Argument options: '${type}' scheme not supported for
        generateKeyPair(). Currently not all encryption methods are supported in
        this library.  Check docs/implementation_coverage.md for status.
      `);
        return [err, undefined, undefined];
      }
  }
  if (isAsync) {
    const impl = async () => {
      try {
        let result;
        if (type === 'rsa' || type === 'rsa-pss') {
          result = await (0, _rsa.rsa_generateKeyPairNode)(type, options, encoding);
        } else if (type === 'ec') {
          result = await (0, _ec.ec_generateKeyPairNode)(options, encoding);
        } else {
          throw new Error(`Unsupported key type: ${type}`);
        }
        return [undefined, result.publicKey, result.privateKey];
      } catch (error) {
        return [error, undefined, undefined];
      }
    };
    impl().then(result => {
      const [err, publicKey, privateKey] = result;
      callback(err, publicKey, privateKey);
    });
    return;
  }
  try {
    let result;
    if (type === 'rsa' || type === 'rsa-pss') {
      result = (0, _rsa.rsa_generateKeyPairNodeSync)(type, options, encoding);
    } else if (type === 'ec') {
      result = (0, _ec.ec_generateKeyPairNodeSync)(options, encoding);
    } else {
      throw new Error(`Unsupported key type: ${type}`);
    }
    return [undefined, result.publicKey, result.privateKey];
  } catch (error) {
    return [error, undefined, undefined];
  }
}
//# sourceMappingURL=generateKeyPair.js.map