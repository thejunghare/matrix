"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCryptoKeyPair = getCryptoKeyPair;
exports.isCryptoKey = void 0;
exports.parseKeyEncoding = parseKeyEncoding;
exports.parsePrivateKeyEncoding = parsePrivateKeyEncoding;
exports.parsePublicKeyEncoding = parsePublicKeyEncoding;
var _utils = require("../utils");
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const isCryptoKey = obj => {
  return obj !== null && obj?.keyObject !== undefined;
};
exports.isCryptoKey = isCryptoKey;
function getCryptoKeyPair(key) {
  if ('publicKey' in key && 'privateKey' in key) return key;
  throw new Error('Invalid CryptoKeyPair');
}

/**
 * Parses the public key encoding based on an object. keyType must be undefined
 * when this is used to parse an input encoding and must be a valid key type if
 * used to parse an output encoding.
 */
function parsePublicKeyEncoding(enc, keyType, objName) {
  return parseKeyEncoding(enc, keyType, keyType ? true : undefined, objName);
}

/**
 * Parses the private key encoding based on an object. keyType must be undefined
 * when this is used to parse an input encoding and must be a valid key type if
 * used to parse an output encoding.
 */
function parsePrivateKeyEncoding(enc, keyType, objName) {
  return parseKeyEncoding(enc, keyType, false, objName);
}
function parseKeyEncoding(enc, keyType, isPublic, objName) {
  // validateObject(enc, 'options');

  const isInput = keyType === undefined;
  const {
    format,
    type
  } = parseKeyFormatAndType(enc, keyType, isPublic, objName);
  let cipher, passphrase, encoding;
  if (isPublic !== true) {
    ({
      cipher,
      passphrase,
      encoding
    } = enc);
    if (!isInput) {
      if (cipher != null) {
        if (typeof cipher !== 'string') throw new Error(`Invalid argument ${option('cipher', objName)}: ${cipher}`);
        if (format === _utils.KFormatType.DER && (type === _utils.KeyEncoding.PKCS1 || type === _utils.KeyEncoding.SEC1)) {
          throw new Error(`Incompatible key options ${encodingNames[type]} does not support encryption`);
        }
      } else if (passphrase !== undefined) {
        throw new Error(`invalid argument ${option('cipher', objName)}: ${cipher}`);
      }
    }
    if (isInput && passphrase !== undefined && !(0, _utils.isStringOrBuffer)(passphrase) || !isInput && cipher != null && !(0, _utils.isStringOrBuffer)(passphrase)) {
      throw new Error(`Invalid argument value ${option('passphrase', objName)}: ${passphrase}`);
    }
  }
  if (passphrase !== undefined) passphrase = (0, _utils.binaryLikeToArrayBuffer)(passphrase, encoding);
  return {
    format,
    type,
    cipher,
    passphrase
  };
}
const encodingNames = {
  [_utils.KeyEncoding.PKCS1]: 'pkcs1',
  [_utils.KeyEncoding.PKCS8]: 'pkcs8',
  [_utils.KeyEncoding.SPKI]: 'spki',
  [_utils.KeyEncoding.SEC1]: 'sec1'
};
function option(name, objName) {
  return objName === undefined ? `options.${name}` : `options.${objName}.${name}`;
}
function parseKeyFormat(formatStr, defaultFormat, optionName) {
  if (formatStr === undefined && defaultFormat !== undefined) return defaultFormat;else if (formatStr === 'pem') return _utils.KFormatType.PEM;else if (formatStr === 'der') return _utils.KFormatType.DER;else if (formatStr === 'jwk') return _utils.KFormatType.JWK;
  throw new Error(`Invalid key format str: ${optionName}`);
}
function parseKeyType(typeStr, required, keyType, isPublic, optionName) {
  if (typeStr === undefined && !required) {
    return undefined;
  } else if (typeStr === 'pkcs1') {
    if (keyType !== undefined && keyType !== 'rsa') {
      throw new Error(`Crypto incompatible key options: ${typeStr} can only be used for RSA keys`);
    }
    return _utils.KeyEncoding.PKCS1;
  } else if (typeStr === 'spki' && isPublic !== false) {
    return _utils.KeyEncoding.SPKI;
  } else if (typeStr === 'pkcs8' && isPublic !== true) {
    return _utils.KeyEncoding.PKCS8;
  } else if (typeStr === 'sec1' && isPublic !== true) {
    if (keyType !== undefined && keyType !== 'ec') {
      throw new Error(`Incompatible key options ${typeStr} can only be used for EC keys`);
    }
    return _utils.KeyEncoding.SEC1;
  }
  throw new Error(`Invalid option ${optionName} - ${typeStr}`);
}
function parseKeyFormatAndType(enc, keyType, isPublic, objName) {
  const {
    format: formatStr,
    type: typeStr
  } = enc;
  const isInput = keyType === undefined;
  const format = parseKeyFormat(formatStr, isInput ? _utils.KFormatType.PEM : undefined, option('format', objName));
  const isRequired = (!isInput || format === _utils.KFormatType.DER) && format !== _utils.KFormatType.JWK;
  const type = parseKeyType(typeStr, isRequired, keyType, isPublic, option('type', objName));
  return {
    format,
    type
  };
}
//# sourceMappingURL=utils.js.map